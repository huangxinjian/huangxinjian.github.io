(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{232:function(s,t,a){"use strict";a.r(t);var e=a(28),v=Object(e.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"mysql-架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql-架构"}},[s._v("#")]),s._v(" MySQL 架构")]),s._v(" "),a("p",[s._v("想要熟悉 MySQL，首先就得清楚 MySQL 中的设计架构，分别有哪些模块，模块对应的功能又是什么。下面将详细介绍 MySQL 的架构。")]),s._v(" "),a("h2",{attrs:{id:"逻辑架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#逻辑架构"}},[s._v("#")]),s._v(" 逻辑架构")]),s._v(" "),a("p",[s._v("首先看一下 MySQL 的架构图：")]),s._v(" "),a("p",[a("img",{attrs:{src:"/mysql_img/mysql-jiagou.jpg",alt:"mysqljiagoutu"}})]),s._v(" "),a("p",[s._v("需要重点关注的是：")]),s._v(" "),a("ul",[a("li",[a("code",[s._v("Connection Pool")]),s._v(" 连接池")]),s._v(" "),a("li",[a("code",[s._v("SQL Interface")]),s._v(" SQL接口层")]),s._v(" "),a("li",[a("code",[s._v("Parser")]),s._v(" 解析器")]),s._v(" "),a("li",[a("code",[s._v("Optimizer")]),s._v(" 优化器")]),s._v(" "),a("li",[a("code",[s._v("Cache & Buffers")]),s._v(" 缓存")]),s._v(" "),a("li",[a("code",[s._v("Pluggable Storage Engines")]),s._v(" 插拔式存储引擎")])]),s._v(" "),a("h3",{attrs:{id:"逻辑架构图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#逻辑架构图"}},[s._v("#")]),s._v(" 逻辑架构图")]),s._v(" "),a("p",[a("img",{attrs:{src:"/mysql_img/sqlshunxu.jpg",alt:"image"}})]),s._v(" "),a("h3",{attrs:{id:"sql-执行顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sql-执行顺序"}},[s._v("#")]),s._v(" SQL 执行顺序")]),s._v(" "),a("h4",{attrs:{id:"连接池"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#连接池"}},[s._v("#")]),s._v(" 连接池")]),s._v(" "),a("p",[s._v("连接池负责管理用户的连接，当用户通过网络往 "),a("code",[s._v("MySQL")]),s._v(" 发起连接请求时，就会通过这个模块进行管理，也就是以下命令：")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[s._v("mysql "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("h$ip "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("P$port "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("u$"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("p\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("当完成 TCP 连接后，就会检查用户输入的用户名和密码是否正确：")]),s._v(" "),a("ul",[a("li",[s._v("如果密码错误，就会报出错误 "),a("code",[s._v("Access denied for user")])]),s._v(" "),a("li",[s._v("如果验证通过，"),a("strong",{staticStyle:{color:"#3EAF7C"}},[s._v("就会去权限表中加载当前用户拥有的权限，并且之后这条连接的权限判断的逻辑，都依赖此时读到的逻辑")])])]),s._v(" "),a("blockquote",[a("p",[s._v("因为如果管理员在用户 A 登录后，再修改用户 A 的权限是不会起作用的。修改后的权限只对新连接起作用")])]),s._v(" "),a("p",[s._v("连接成功后，如果没有后续操作，该条连接就会进入"),a("strong",{staticStyle:{color:"#3EAF7C"}},[s._v("空闲状态")]),s._v("，直到 Mysql 将其断开。这个持续时间默认是 8 小时，可以通过参数 "),a("code",[s._v("wait_timeout")]),s._v(" 控制。")]),s._v(" "),a("p",[s._v("如果想查询空闲连接，可以通过 "),a("code",[s._v("show processlist")]),s._v(" 查看当前所有连接的状态：")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/f2/ed/f2da4aa3a672d48ec05df97b9f992fed.png",alt:"image"}})]),s._v(" "),a("p",[s._v("如果超时断开后，客户端发起请求，则会收到一个错误提示 ： "),a("code",[s._v("Lost connection to MySQL server during query")]),s._v(" ，这时候我们需要重新连接后才能发起请求。")]),s._v(" "),a("h5",{attrs:{id:"长连接与短连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#长连接与短连接"}},[s._v("#")]),s._v(" 长连接与短连接")]),s._v(" "),a("p",[s._v("数据库里连接一共分为长连接和短连接，其中：")]),s._v(" "),a("ul",[a("li",[s._v("长连接是指连接成功后，客户端不断有请求发送，此时会一直使用同一个连接。")]),s._v(" "),a("li",[s._v("而短连接是每次执行完很少的几次查询就会断开连接，下次查询重新建立一个。")])]),s._v(" "),a("p",[s._v("建立连接的过程是比较复杂的，因此"),a("strong",{staticStyle:{color:"#3EAF7C"}},[s._v("建议通常使用长连接")]),s._v("， 即连接池。")]),s._v(" "),a("p",[s._v("但是如果大量使用长连接，则会出现内存暴涨的情况，这是因为 "),a("strong",[s._v("MySQL")]),s._v(" 在执行过程中临时使用的内存是管理在连接对象里面的，只要这些资源没被释放，内存也不会被释放。")]),s._v(" "),a("p",[s._v("因此为了解决该方案，我们需要：")]),s._v(" "),a("ul",[a("li",[s._v("定期断开长连接")]),s._v(" "),a("li",[s._v("如果是 5.7 或更新版本，可以通过 "),a("strong",[s._v("mysql_reset_connection")]),s._v(" 来重新初始化连接资源，这个过程不需要重连和权限验证，只会将连接恢复到刚刚创建时的状态。")])]),s._v(" "),a("h4",{attrs:{id:"sql-接口层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sql-接口层"}},[s._v("#")]),s._v(" SQL 接口层")]),s._v(" "),a("p",[s._v("连接成功后，发起查询请求：")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("这时就会被 SQL 接口层接受该条 SQL, "),a("strong",{staticStyle:{color:"#3EAF7C"}},[s._v("然后判断该用户是否有操作这个表的权限")]),s._v("，如果有就传递解析器进行处理。")]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),a("p",[s._v("其实在传递给解析器之前，会先去 Cache 缓存中查询，不过 8.0 后就已经移除缓存了，这个缓存的作用并不大。")])]),s._v(" "),a("h4",{attrs:{id:"查询缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查询缓存"}},[s._v("#")]),s._v(" 查询缓存")]),s._v(" "),a("blockquote",[a("p",[s._v("mysql 8.0 后移除了这个模块")])]),s._v(" "),a("p",[s._v("MySQL拿到一个查询请求后，会先到查询缓存中查看该条语句是否被执行过，之前执行过的语句和查询出来的结果会以 "),a("code",[s._v("key-value")]),s._v(" 的形式缓存在内存中，其中 "),a("code",[s._v("key")]),s._v(" 是查询的语句，"),a("code",[s._v("value")]),s._v(" 是查询的结果。")]),s._v(" "),a("p",[s._v("如果我们的查询语句可以直接在缓存中找到对应的 "),a("code",[s._v("key")]),s._v("，则可以直接返回结果，不用继续走下面复杂的流程。因此这样的效率是很高的！")]),s._v(" "),a("p",[s._v("但是，大多数情况下不建议使用查询缓存，它会弊大于利，因为"),a("strong",{staticStyle:{color:"#3EAF7C"}},[s._v("只要有一条记录对这个表进行更新，这个表上的所有查询缓存都会失效，")]),s._v("因此查询缓存只能有效用于静态表，例如 系统配置表。")]),s._v(" "),a("p",[s._v("因此，MySQL 也提供了一种方式让我们按需索取该功能，即我们可以将参数 "),a("code",[s._v("query_cache_type")]),s._v(" 设置成 "),a("code",[s._v("DEMAND")]),s._v(", 这样对于默认的查询SQL都不会使用查询缓存。")]),s._v(" "),a("p",[s._v("当我们需要使用到查询缓存的时候，可以通过显示指定 "),a("code",[s._v("SQL_CACHE")]),s._v(" :")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" SQL_CACHE "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" T "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" ID"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v("；\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h4",{attrs:{id:"解析器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解析器"}},[s._v("#")]),s._v(" 解析器")]),s._v(" "),a("p",[s._v("解析器拿到 SQL 语句后，会进行两步解析：")]),s._v(" "),a("ul",[a("li",[s._v("词法解析")]),s._v(" "),a("li",[s._v("语法解析")])]),s._v(" "),a("p",[s._v("其中词法解析就是解剖 SQL 语句，将其中的每个单词都分离出来，挂载到一颗语法树上，大概是这种效果：")]),s._v(" "),a("p",[a("img",{attrs:{src:"/mysql_img/mysql_cifajiexi.jpg",alt:"IMAGE"}})]),s._v(" "),a("p",[s._v("词法解析完成后就会进行语法解析，MySQL 会判断你的 SQL 语句存不存在语法错误。如果存在错误，一般会报出这样的异常：")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[s._v("You have an error "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("in")]),s._v(" your "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SQL")]),s._v(" syntax"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("check")]),s._v(" the manual that corresponds "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("to")]),s._v(" your MySQL server version "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" the "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("right")]),s._v(" syntax "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("to")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("use")]),s._v(" near "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'elect * from t where ID=1'")]),s._v(" at line "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),a("p",[s._v("一般语法会提示第一个出现错误的位置，因此我们需要关注紧接 use near 后面的内容")])]),s._v(" "),a("h4",{attrs:{id:"优化器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化器"}},[s._v("#")]),s._v(" 优化器")]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),a("p",[s._v("性能优化就是指的这一块了")])]),s._v(" "),a("p",[s._v("经过了分析器后，MySQL 已经知道我们要做什么了，然后在执行前，还要先经过 优化器 为我们的 SQL 进行优化。")]),s._v(" "),a("p",[s._v("优化器是在一个表有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联的时候，决定各个表的连接顺序，例如：")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" t1 "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("join")]),s._v(" t2 "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("using")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("ID"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" t1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("c"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("and")]),s._v(" t2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("d"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("ol",[a("li",[s._v("既可以先从表 t1 中取出 c=10的数据，然后再跟 t2 连接，再判断 t2.d=20 的数据。")]),s._v(" "),a("li",[s._v("也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。")])]),s._v(" "),a("p",[s._v("这两种方案最终得到的结果都是一样的，但是效率可能识不同的，因此这就是优化器的工作。")]),s._v(" "),a("blockquote",[a("p",[s._v("优化器不一定是每次都能做到 提高效率的优化！")])]),s._v(" "),a("h4",{attrs:{id:"执行器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行器"}},[s._v("#")]),s._v(" 执行器")]),s._v(" "),a("p",[s._v("MySQL 通过分析器分析你要做什么，通过优化器知道要怎么做，然后就来到最后一步 执行器 阶段了。")]),s._v(" "),a("p",[s._v("在执行语句前，会先判断你对这个表有没有操作权限，如果没有，则会返回没有权限的错误信息。例如：")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("mysql"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" * from T where "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("ID")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nERROR "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1142")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("42000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(": SELECT "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("command")]),s._v(" denied to user "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'b'")]),s._v("@"),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'localhost'")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" table "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'T'")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[s._v("注意")]),s._v(" "),a("p",[s._v("如果语句命中了查询缓存，也会在返回结果之前查看是否有权限。同时，在优化器之前也会调用 precheck 做权限验证。")])]),s._v(" "),a("p",[s._v("如果存在权限，则会打开表继续执行，打开表的时候，执行器就会根据这个表的存储引擎定义，去使用这个引擎提供的接口。")]),s._v(" "),a("p",[s._v("比如上面的这一条SQL,执行器的执行流程就是这样的（ID并不是主键，不存在索引）：")]),s._v(" "),a("ol",[a("li",[s._v("调用 InnoDB 引擎接口取这个表的第一行，判断 ID 是否等于 10，如果不是则跳过，如果是则将 该记录存储到结果集中。")]),s._v(" "),a("li",[s._v("调用引擎取下一行，以此类推。直到取到这个表的最后一行")]),s._v(" "),a("li",[s._v("然后将最终的"),a("strong",[s._v("行记录集")]),s._v("返回给客户端")])]),s._v(" "),a("p",[s._v("我们可以在 慢查询日志 中看到一个 "),a("code",[s._v("row_examined")]),s._v(" 的字段，表示了这条 "),a("code",[s._v("SQL")]),s._v(" 扫描了多少行，这个值就是执行器调用存储引擎获取数据行的时候累加的。")]),s._v(" "),a("blockquote",[a("p",[s._v("在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 "),a("code",[s._v("rows_examined")]),s._v(" 并不是完全相同的。")])]),s._v(" "),a("p",[s._v("至此，一条SQL已经执行完毕了。")]),s._v(" "),a("h2",{attrs:{id:"存储引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储引擎"}},[s._v("#")]),s._v(" 存储引擎 💥")]),s._v(" "),a("p",[s._v("在创建表的时候，通常可以"),a("strong",[s._v("为表指定")]),s._v("一个存储引擎，它规定了表中数据、索引的存储结构：")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("create")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("table")]),s._v(" xxx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("engine")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("InnoDB")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("Memory"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("MyISAM\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),a("p",[s._v("表一旦被创建，存储结构就无法被改变。")])]),s._v(" "),a("p",[s._v("上面指定的 "),a("code",[s._v("InnoDB")]),s._v(" 、"),a("code",[s._v("MyISAM")]),s._v("、"),a("code",[s._v("Memory")]),s._v(" 就是 MySQL 中最常用的三种存储引擎了。")]),s._v(" "),a("h3",{attrs:{id:"memory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#memory"}},[s._v("#")]),s._v(" Memory")]),s._v(" "),a("p",[a("code",[s._v("Memory")]),s._v(" 是内存存储引擎，特点是"),a("strong",{staticStyle:{color:"#3EAF7C"}},[s._v("存储、查询速度极快，但是不能持久化数据，适合存储系统的一些配置信息，每次启动时都会加载")]),s._v("。对于核心数据不建议使用该存储引擎，因为会导致数据丢失。")]),s._v(" "),a("h3",{attrs:{id:"myisam"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#myisam"}},[s._v("#")]),s._v(" MyISAM")]),s._v(" "),a("p",[a("code",[s._v("MyISAM")]),s._v(" 是 MySQL 原生支持的存储引擎，它拥有"),a("strong",{staticStyle:{color:"#3EAF7C"}},[s._v("较高的存储效率")]),s._v("。但是它不支持事务、不支持行锁。")]),s._v(" "),a("h3",{attrs:{id:"innodb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#innodb"}},[s._v("#")]),s._v(" InnoDB")]),s._v(" "),a("p",[a("code",[s._v("InnoDB")]),s._v(" 是由第三方公司开发的，它的插入、查询速度比 "),a("code",[s._v("MyISAM")]),s._v(" 要稍微慢些，但是它"),a("strong",{staticStyle:{color:"#3EAF7C"}},[s._v("支持事务、行级锁、回滚、崩溃恢复以及多版本并发控制")]),s._v("。")]),s._v(" "),a("h3",{attrs:{id:"innodb-和-myisam-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#innodb-和-myisam-的区别"}},[s._v("#")]),s._v(" InnoDB 和 MyISAM 的区别 ❓")]),s._v(" "),a("p",[a("img",{attrs:{src:"/mysql_img/innodbandmyisam.jpg",alt:"ima"}})]),s._v(" "),a("h3",{attrs:{id:"技术选型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#技术选型"}},[s._v("#")]),s._v(" 技术选型")]),s._v(" "),a("ol",[a("li",[s._v("如果对数据的插入、查询性能要求很高，但是不需要数据的持久化，并且表的大小不是很大，则可以使用 "),a("code",[s._v("Memory")]),s._v(" 存储引擎")]),s._v(" "),a("li",[s._v("如果要求较高的插入、查询效率，对并发要求不高，则可以使用 "),a("code",[s._v("MyISAM")]),s._v(" 存储引擎")]),s._v(" "),a("li",[s._v("如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择 "),a("code",[s._v("InnoDB")]),s._v(" 有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择 "),a("code",[s._v("InnoDB")]),s._v("，因为支持事务的提交"),a("code",[s._v("（commit）")]),s._v("和回滚"),a("code",[s._v("（rollback）")]),s._v("。")])]),s._v(" "),a("h2",{attrs:{id:"物理架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#物理架构"}},[s._v("#")]),s._v(" 物理架构")]),s._v(" "),a("p",[s._v("MySQL 实际上是通过文件来管理数据索引以及日志的，在 MySQL 中，一共分为两种文件：")]),s._v(" "),a("ul",[a("li",[s._v("日志文件")]),s._v(" "),a("li",[s._v("数据索引文件")])]),s._v(" "),a("p",[s._v("其中日志文件采用"),a("strong",{staticStyle:{color:"#3EAF7C"}},[s._v("顺序IO")]),s._v("的方式写入，速度快，空间利用率低，数据索引文件采用"),a("strong",{staticStyle:{color:"#3EAF7C"}},[s._v("随机IO")]),s._v("的方式写入，需要记录地址，比较慢，但是空间利用率高")]),s._v(" "),a("p",[s._v("另外，MySQL在 "),a("code",[s._v("Linux")]),s._v(" 中的数据索引文件和日志文件都在 "),a("code",[s._v("/var/lib/mysql")]),s._v(" 目录下。")]),s._v(" "),a("p",[a("img",{attrs:{src:"/mysql_img/FILE.jpg",alt:"img"}})]),s._v(" "),a("h3",{attrs:{id:"日志文件种类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#日志文件种类"}},[s._v("#")]),s._v(" 日志文件种类")]),s._v(" "),a("p",[s._v("MySQL 中，日志文件有很多种，分别是：")]),s._v(" "),a("ul",[a("li",[s._v("错误日志 "),a("code",[s._v("error log")])]),s._v(" "),a("li",[s._v("通用查询日志 "),a("code",[s._v("general query log")])]),s._v(" "),a("li",[s._v("慢查询日志 "),a("code",[s._v("slow query log")])]),s._v(" "),a("li",[s._v("二进制日志 "),a("code",[s._v("binlog")])]),s._v(" "),a("li",[s._v("重做日志 "),a("code",[s._v("redo log")])]),s._v(" "),a("li",[s._v("回滚日志 "),a("code",[s._v("undo log")])]),s._v(" "),a("li",[s._v("中继日志 "),a("code",[s._v("relay log")])])]),s._v(" "),a("p",[s._v("如果想要查看日志的开启情况，可以通过命令：")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("show")]),s._v(" variables "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("like")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'log_%'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h3",{attrs:{id:"错误日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#错误日志"}},[s._v("#")]),s._v(" 错误日志")]),s._v(" "),a("p",[a("strong",{staticStyle:{color:"#3EAF7C"}},[s._v("默认是开启的，而且从5.5.7以后无法关闭错误日志")]),s._v("，错误日志记录了运行过程中遇到的所有严重的错误信息,以及 MySQL每次启动和关闭的详细信息")]),s._v(" "),a("h3",{attrs:{id:"通用查询日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通用查询日志"}},[s._v("#")]),s._v(" 通用查询日志")]),s._v(" "),a("p",[s._v("这个一般在生产中是不会开启的，因为它会记录所有的 SQL 操作，十分影响性能。")]),s._v(" "),a("h3",{attrs:{id:"慢查询日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#慢查询日志"}},[s._v("#")]),s._v(" 慢查询日志")]),s._v(" "),a("p",[s._v("SQL 调优时使用，可以查看一些 SQL 执行慢的语句，默认是关闭的。需要通过以下设置进行开启：")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#开启慢查询日志")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("slow_query_log")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("ON\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#慢查询的阈值")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("long_query_time")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#日志记录文件如果没有给出file_name值， 默认为主机名，后缀为-slow.log。")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#如果给出了文件名，但不是绝对路径名，文件则写入数据目录。")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("slow_query_log_file")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("file_name\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("h3",{attrs:{id:"二进制文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二进制文件"}},[s._v("#")]),s._v(" 二进制文件 👍")]),s._v(" "),a("p",[a("code",[s._v("bin log")]),s._v(" 是 MySQL 中最重要的日志文件之一，它"),a("strong",{staticStyle:{color:"#3EAF7C"}},[s._v("记录了数据库所有的ddl语句和dml语句，但不包括select语句内容")]),s._v("。")]),s._v(" "),a("p",[s._v("语句以事件的形式保存，描述了数据的变更顺序，binlog还包括了每个更新语句的执行时间信息。如果是DDL语句，则直接记录到 "),a("code",[s._v("binlog")]),s._v(" 日志，而 "),a("code",[s._v("DML语句")]),s._v("，必须通过事务提交才能记录到 "),a("code",[s._v("binlog")]),s._v("日志中，生产中开启。")]),s._v(" "),a("p",[s._v("后面要介绍的主从复制、主备、数据恢复都是依赖 "),a("code",[s._v("binlog")]),s._v(" 来操作的。")]),s._v(" "),a("h3",{attrs:{id:"重做日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重做日志"}},[s._v("#")]),s._v(" 重做日志 👍")]),s._v(" "),a("p",[a("code",[s._v("redo log")]),s._v(" 是属于存储引擎 "),a("code",[s._v("InnoDB")]),s._v(" 特有的日志，每当有一个 "),a("code",[s._v("DML操作")]),s._v(" ，就会记录多一条回滚操作到 "),a("code",[s._v("redo log")]),s._v(" 中，同时 "),a("code",[s._v("redo log")]),s._v(" 还会记录数据的变化情况。")]),s._v(" "),a("p",[s._v("该日志文件是存储在 "),a("code",[s._v("var/lib/mysql")]),s._v(" 下的 "),a("code",[s._v("ib_logfile0")]),s._v(" 和 "),a("code",[s._v("ib_logfile1")]),s._v(" ，这两个文件就是重做日志，大小每个 8M。可以通过 "),a("code",[s._v("show variables like 'innodb_log%'")]),s._v(" 查询")]),s._v(" "),a("p",[s._v("作用：")]),s._v(" "),a("ul",[a("li",[s._v("防止在发生故障的时间点时，内存中尚有脏页")]),s._v(" "),a("li",[s._v("如果未写入磁盘（事务提交之后，数据写入磁盘之前宕机），在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。")])]),s._v(" "),a("p",[s._v("内容：")]),s._v(" "),a("ul",[a("li",[s._v("物理格式的日志，记录的是物理数据页面的修改信息，其 "),a("code",[s._v("redo log")]),s._v(" 是顺序IO写入 "),a("code",[s._v("redo log file")]),s._v(" 的物理文件中去的。")])]),s._v(" "),a("p",[s._v("生成时机：")]),s._v(" "),a("ul",[a("li",[a("strong",{staticStyle:{color:"#3EAF7C"}},[s._v("事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的")]),s._v("，而是在事务的执行过程中，便开始写入redo log文件中。")])]),s._v(" "),a("p",[s._v("释放时机：")]),s._v(" "),a("ul",[a("li",[s._v("当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。")])]),s._v(" "),a("h3",{attrs:{id:"回滚日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回滚日志"}},[s._v("#")]),s._v(" 回滚日志 👍")]),s._v(" "),a("p",[a("code",[s._v("回滚日志")]),s._v(" 称为 "),a("code",[s._v("undo log")]),s._v("，这个记录也是记录在 "),a("code",[s._v("redo log")]),s._v(" 里面的。可以将 "),a("code",[s._v("undo log")]),s._v(" 理解为跟数据页一样类型的数据，只不过数据页记录的是新数据，"),a("code",[s._v("undo log page")]),s._v(" 记录的是回滚数据")]),s._v(" "),a("p",[s._v("作用：")]),s._v(" "),a("ul",[a("li",[s._v("保存了事务发生之前数据的一个版本，可以用于回滚。事务回滚时，会根据 "),a("code",[s._v("undo log")]),s._v(" 将数据从逻辑上恢复至事务之前的状态。")])]),s._v(" "),a("p",[s._v("内容：")]),s._v(" "),a("ul",[a("li",[s._v("逻辑格式的日志，在执行 "),a("code",[s._v("undo")]),s._v(" 的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于 "),a("code",[s._v("redo log")]),s._v(" 的。")])]),s._v(" "),a("p",[s._v("生成时机：")]),s._v(" "),a("ul",[a("li",[s._v("事务开始之前，将当前事务版本生成 undo log，"),a("strong",{staticStyle:{color:"#3EAF7C"}},[s._v("undo 也会产生 redo 来保证 undo log 的可靠性。")])]),s._v(" "),a("li",[s._v("每一次写操作都会生成 undo log\n"),a("ul",[a("li",[s._v("比如 update 操作，会生成一条更新前的记录信息，比如主键ID，需要更新的字段以及字段对应的旧值。")]),s._v(" "),a("li",[s._v("对于 DELETE 操作，在 delete mark 操作时，会获取该条记录最近一次的 undo log 记录")])])]),s._v(" "),a("li",[s._v("生成的新的 undo log 记录了旧记录的 "),a("code",[s._v("trx_id")]),s._v("（事务编号） 和 "),a("code",[s._v("old roll_pointer")]),s._v("（上一个 undo log 的位置,回滚指针） ，这样回滚时，就可以直接找到删除之前的 undo log 进行回滚操作。")])]),s._v(" "),a("p",[s._v("释放时机：")]),s._v(" "),a("ul",[a("li",[s._v("当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由 purge 线程判断是否有其他事务在使用 undo 段中表的上一个事务之前的版本信息，决定是否可以清理 undo log 的日志空间")])]),s._v(" "),a("h3",{attrs:{id:"中继日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#中继日志"}},[s._v("#")]),s._v(" 中继日志 👍")]),s._v(" "),a("h3",{attrs:{id:"数据文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据文件"}},[s._v("#")]),s._v(" 数据文件")]),s._v(" "),a("p",[s._v("如果使用 "),a("code",[s._v("InnoDB")]),s._v(" 引擎，则数据文件分为三种：")]),s._v(" "),a("ul",[a("li",[a("code",[s._v(".frm")]),s._v("：表结构定义文件")]),s._v(" "),a("li",[a("code",[s._v(".ibd")]),s._v(": 使用"),a("strong",{staticStyle:{color:"#3EAF7C"}},[s._v("独享表空间")]),s._v("保存表数据和索引信息，一个表对应一个 "),a("code",[s._v(".ibd")]),s._v(" 文件。")]),s._v(" "),a("li",[a("code",[s._v("ibdata")]),s._v("：使用"),a("strong",{staticStyle:{color:"#3EAF7C"}},[s._v("共享表空间")]),s._v("保存表数据和索引信息，所有表共同使用一个或多个 "),a("code",[s._v(".ibdata")]),s._v(" 文件。")])]),s._v(" "),a("p",[s._v("如果使用 "),a("code",[s._v("MyISAM")]),s._v(" 引擎，数据文件也分为三种，不过数据和索引是分开存放的：")]),s._v(" "),a("ul",[a("li",[a("code",[s._v(".frm")]),s._v("：表结构定义文件")]),s._v(" "),a("li",[a("code",[s._v(".myd")]),s._v(": 主要用来存储表数据信息")]),s._v(" "),a("li",[a("code",[s._v(".myi")]),s._v(": 主要用来存储表数据文件中任何索引的索引树")])])])}),[],!1,null,null,null);t.default=v.exports}}]);