<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MySQL 事务 | HuangXinJian</title>
    <meta name="description" content="If you learn, learn deeply please!">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="icon" href="/H.png">
    
    <link rel="preload" href="/assets/css/0.styles.77838d5e.css" as="style"><link rel="preload" href="/assets/js/app.78cba7d9.js" as="script"><link rel="preload" href="/assets/js/2.b97de27f.js" as="script"><link rel="preload" href="/assets/js/6.bb2aa06c.js" as="script"><link rel="prefetch" href="/assets/js/10.5a39f9cf.js"><link rel="prefetch" href="/assets/js/11.fc6bddf2.js"><link rel="prefetch" href="/assets/js/12.da1eaab3.js"><link rel="prefetch" href="/assets/js/13.3e791f4e.js"><link rel="prefetch" href="/assets/js/14.5953a388.js"><link rel="prefetch" href="/assets/js/15.b9e792e3.js"><link rel="prefetch" href="/assets/js/16.14be3228.js"><link rel="prefetch" href="/assets/js/17.d8c48abe.js"><link rel="prefetch" href="/assets/js/18.c1171d86.js"><link rel="prefetch" href="/assets/js/19.687638f3.js"><link rel="prefetch" href="/assets/js/20.dbb7c712.js"><link rel="prefetch" href="/assets/js/21.fcac9d7b.js"><link rel="prefetch" href="/assets/js/22.05c89a82.js"><link rel="prefetch" href="/assets/js/23.6f455ef9.js"><link rel="prefetch" href="/assets/js/24.a5f5dd42.js"><link rel="prefetch" href="/assets/js/25.ddacf5f1.js"><link rel="prefetch" href="/assets/js/26.1dbabccd.js"><link rel="prefetch" href="/assets/js/27.4d3ddddd.js"><link rel="prefetch" href="/assets/js/28.aca93b2e.js"><link rel="prefetch" href="/assets/js/29.4e592fcf.js"><link rel="prefetch" href="/assets/js/3.8c3b122e.js"><link rel="prefetch" href="/assets/js/30.07e05cf0.js"><link rel="prefetch" href="/assets/js/31.4bc393d7.js"><link rel="prefetch" href="/assets/js/32.5bed9ede.js"><link rel="prefetch" href="/assets/js/33.b1d61159.js"><link rel="prefetch" href="/assets/js/34.27c7f1f1.js"><link rel="prefetch" href="/assets/js/35.17c92a26.js"><link rel="prefetch" href="/assets/js/36.91a5ecf5.js"><link rel="prefetch" href="/assets/js/37.88c250af.js"><link rel="prefetch" href="/assets/js/38.6d72295b.js"><link rel="prefetch" href="/assets/js/39.0e585af1.js"><link rel="prefetch" href="/assets/js/4.ff5f2a88.js"><link rel="prefetch" href="/assets/js/40.80a7f1c2.js"><link rel="prefetch" href="/assets/js/41.defa3efa.js"><link rel="prefetch" href="/assets/js/42.70857ada.js"><link rel="prefetch" href="/assets/js/5.68065b24.js"><link rel="prefetch" href="/assets/js/7.f469350c.js"><link rel="prefetch" href="/assets/js/8.37ca51cf.js"><link rel="prefetch" href="/assets/js/9.68f4fa83.js">
    <link rel="stylesheet" href="/assets/css/0.styles.77838d5e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">HuangXinJian</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="NodeJS" class="dropdown-title"><span class="title">NodeJS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/nodejs/NodeJS基础/NodeJS介绍.html" class="nav-link">
  NodeJS 基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java/baseJava/Java 介绍.html" class="nav-link">
  Java 基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分布式" class="dropdown-title"><span class="title">分布式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/distributed/frameworkHistory/架构演变历史.html" class="nav-link">
  分布式学习路线
</a></li><li class="dropdown-item"><!----> <a href="/distributed/registerCenter/" class="nav-link">
  注册中心
</a></li><li class="dropdown-item"><!----> <a href="/distributed/messageSystem/" class="nav-link">
  消息系统
</a></li><li class="dropdown-item"><!----> <a href="/distributed/internal/" class="nav-link">
  网络框架
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          关系型数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/database/RDB/MySQL_Learn/MySQL安装.html" class="nav-link">
  MySQL
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="https://github.com/huangxinjian/huangxinjian.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="NodeJS" class="dropdown-title"><span class="title">NodeJS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/nodejs/NodeJS基础/NodeJS介绍.html" class="nav-link">
  NodeJS 基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java/baseJava/Java 介绍.html" class="nav-link">
  Java 基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分布式" class="dropdown-title"><span class="title">分布式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/distributed/frameworkHistory/架构演变历史.html" class="nav-link">
  分布式学习路线
</a></li><li class="dropdown-item"><!----> <a href="/distributed/registerCenter/" class="nav-link">
  注册中心
</a></li><li class="dropdown-item"><!----> <a href="/distributed/messageSystem/" class="nav-link">
  消息系统
</a></li><li class="dropdown-item"><!----> <a href="/distributed/internal/" class="nav-link">
  网络框架
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          关系型数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/database/RDB/MySQL_Learn/MySQL安装.html" class="nav-link">
  MySQL
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="https://github.com/huangxinjian/huangxinjian.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>MySQL</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/database/RDB/MySQL_Learn/MySQL安装.html" class="sidebar-link">MySQL 单机安装</a></li><li><a href="/database/RDB/MySQL_Learn/MySQL基础语法.html" class="sidebar-link">MySQL 基础语法</a></li><li><a href="/database/RDB/MySQL_Learn/MySQL架构.html" class="sidebar-link">MySQL 架构</a></li><li><a href="/database/RDB/MySQL_Learn/MySQL索引.html" class="sidebar-link">MySQL 索引</a></li><li><a href="/database/RDB/MySQL_Learn/MySQL索引详细分析.html" class="sidebar-link">MySQL 索引详细分析</a></li><li><a href="/database/RDB/MySQL_Learn/MySQL锁.html" class="sidebar-link">MySQL 锁</a></li><li><a href="/database/RDB/MySQL_Learn/MySQL事务.html" class="active sidebar-link">MySQL 事务</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#事务的作用" class="sidebar-link">事务的作用</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#事务的特性" class="sidebar-link">事务的特性</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#开启事务" class="sidebar-link">开启事务</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#innodb-架构" class="sidebar-link">InnoDB 架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#buffer-pool" class="sidebar-link">Buffer Pool</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#insert-buffer-page" class="sidebar-link">insert buffer page</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#redo-log-buffer" class="sidebar-link">redo log buffer</a></li></ul></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#innodb-的磁盘结构" class="sidebar-link">InnoDB 的磁盘结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#共享表空间" class="sidebar-link">共享表空间</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#用户表空间" class="sidebar-link">用户表空间</a></li></ul></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#事务持久化实现机制" class="sidebar-link">事务持久化实现机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#重做日志落盘机制" class="sidebar-link">重做日志落盘机制</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#双写机制" class="sidebar-link">双写机制</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#双写机制的作用" class="sidebar-link">双写机制的作用</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#双写机制的策略" class="sidebar-link">双写机制的策略</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#sharp-checkpoint" class="sidebar-link">sharp checkpoint</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#fuzzy-checkpoint" class="sidebar-link">fuzzy checkpoint</a></li></ul></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#事务隔离性实现机制" class="sidebar-link">事务隔离性实现机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#隔离级别介绍" class="sidebar-link">隔离级别介绍</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#各个隔离级别的问题" class="sidebar-link">各个隔离级别的问题</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#mvcc-实现" class="sidebar-link">MVCC 实现</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#undo-log" class="sidebar-link">Undo Log</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#事务链表" class="sidebar-link">事务链表</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#read-view" class="sidebar-link">read view</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#mvcc-的运作流程" class="sidebar-link">MVCC 的运作流程</a></li><li class="sidebar-sub-header"><a href="/database/RDB/MySQL_Learn/MySQL事务.html#快照读和当前读" class="sidebar-link">快照读和当前读</a></li></ul></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="mysql-事务"><a href="#mysql-事务" class="header-anchor">#</a> MySQL 事务</h1> <p>事务是保证一组数据库操作要么全部成功，要么全部失败，例如小李给小张转账100元，需要扣除小李的余额和新增小张的余额，这两个操作都必须同时成功，只要有一个失败，另外一个就算成功了，也算是失败。</p> <p>在 MySQL 中，事务是由存储引擎层实现的，并且实现了事务的存储引擎并不多，<code>InnoDB</code> 就是其中一个。下面也是重点介绍 <code>InnoDB</code> 实现的事务机制。</p> <h2 id="事务的作用"><a href="#事务的作用" class="header-anchor">#</a> 事务的作用</h2> <p>事务可以用来管理一系列的 <code>DML、DCL、DDL</code> 语句，比如 <code>insert</code>、<code>update</code>、<code>delete</code> 这些需要操作表数据的语句。<strong style="color:#3EAF7C;">另外，事务默认情况下是自动提交的</strong></p> <p>不过事务的自动提交可以通过 <code>set autocommit=0</code> 来关闭掉，但是这样当我们执行一个 <code>select</code> 语句时，事务就会被开启，并且不会被自动提交除非我们主动执行了 <code>commit</code> 或 <code>rollback</code> 或者被断开了连接。</p> <h2 id="事务的特性"><a href="#事务的特性" class="header-anchor">#</a> 事务的特性</h2> <p>事务有著名的四大特性 —— <code>ACID</code> ，分别是：</p> <ul><li>原子性（Atomicity）：构成事务的的所有操作必须是一个逻辑单元，要么全部执行，要么全部不执行。</li> <li>一致性（Consistency）：数据库在事务执行前后状态都必须是稳定的或者是一致的。</li> <li>隔离性（Isolation）：不同的事务之间不会相互影响</li> <li>持久性（Durability）：事务执行成功后必须全部写入磁盘</li></ul> <h2 id="开启事务"><a href="#开启事务" class="header-anchor">#</a> 开启事务</h2> <p>开启事务通常通过 <code>begin</code> 或 <code>start transaction</code> , 或者 <code>start transaction with consistent snapshot</code> 这两者之间的区别会在后面的 MVCC 多版本并发控制进行讲解。</p> <p>当一组数据库操作执行完成后，需要对事务进行提交或者回滚：</p> <ul><li>提交通过 <code>commit</code>，当提交事务后，数据会被持久化到磁盘中。</li> <li>回滚通过 <code>rollback</code>，当回滚事务后，会撤销该事务正在进行的未提交的修改。</li></ul> <p>因为事务是由 innodb 实现的，下面详细介绍 innodb 存储引擎是如何实现事务的。</p> <h2 id="innodb-架构"><a href="#innodb-架构" class="header-anchor">#</a> InnoDB 架构</h2> <p>首先看一下 <code>innoDb</code> 的架构图：</p> <p><img src="/mysql_img/innodbjiagou.png" alt="mysql"></p> <p>可以看到，<code>InnoDB</code> 一共分为四个区域</p> <ol><li>一个是最上方的内存区，用来暂时保存 SQL 执行的结果</li> <li>中间是 MySQL 的工作线程，用来负责将数据进行持久化到硬盘和清理日志文件</li> <li>然后是操作系统的内核缓存，用来中转数据</li> <li>最后就是物理文件了，包括共享表空间和用户表空间以及日志文件。</li></ol> <h3 id="buffer-pool"><a href="#buffer-pool" class="header-anchor">#</a> Buffer Pool</h3> <p><code>Buffer Pool</code> 是 MySQL 的内存缓冲池，用来暂时存放事务中修改的数据，它分为六个区域：</p> <ul><li><code>data page</code>：数据页</li> <li><code>index page</code>：索引页</li> <li><code>insert buffer page</code>：插入页</li> <li><code>adaptive hash index</code>：自适应hash</li> <li><code>lock info</code>：锁信息</li> <li><code>data dictionary</code>：数据字典</li></ul> <p><strong>data page</strong></p> <p>这里存储的是数据页，首先要明确的是，页是 InnoDB 中的最基本的存储结构，也是 <code>InnoDB</code> 磁盘管理的最小单位，一页的大小是 <code>16KB</code>。每当执行修改删除的时候，旧数据页都会先被读取到内存中，也就是 <code>buffer pool</code> ，然后在这个内存页上进行修改或删除，<strong style="color:#3EAF7C;">这样的页与磁盘上的页数据是不一致的，并且由于还没持久化到磁盘上，被称之为脏页</strong>。</p> <p><strong>adaptive hash index</strong></p> <p>自适应 hash 索引，是 <code>InnoDB</code> 为了加快检索效率的一种机制，它会将一些查询次数的多的，即热点数据，为热点页建立一个hash索引，加快查询效率。</p> <p><strong>lock info</strong></p> <p>记录行锁、表锁等信息</p> <p><strong>data dictionary</strong>
数据字典，记录元数据信息，例如表结果、数据库名、表名、字段的数据类型、视图、索引、表字段信息、存储过程、触发器等内容。</p> <h3 id="insert-buffer-page"><a href="#insert-buffer-page" class="header-anchor">#</a> insert buffer page</h3> <p><code>insert buffer page</code> 在新版本后又称为 <code>change buffer</code>，因为也可以支持 <code>update</code>、<code>delete</code> 了。这个 buffer 的作用是可以减少随机IO读取表空间的损耗。</p> <p>当在进行插入、更新、删除操作的时候，如果在内存中没有找到对应的数据页来修改的话，有两种方式来记录这个改变：</p> <ul><li>从磁盘中读出这个页的数据到内存中，然后修改它形成脏页</li> <li>先将这个步骤存放在某一个特殊的内存区中，等到下次有事务读这个页的数据的时候，再进行 <code>merge</code> 操作合并形成脏页，再返回读取的结果。</li></ul> <p>其中第二种方式就可以有效降低磁盘随机IO读取页的损耗，它可以先囤一定数量的操作在内存中，等到有人读的时候，再形成结果返回。</p> <h3 id="redo-log-buffer"><a href="#redo-log-buffer" class="header-anchor">#</a> redo log buffer</h3> <p><code>redo log buffer</code> 叫做重做日志缓冲，最大的作用就是<strong style="color:#3EAF7C;">可以实现崩溃恢复</strong>，这是因为在 <code>InnoDB</code> 中，在持久化数据之前，即提交事务的时候，会先将数据的物理修改内容写入<code>redo log</code>日志中，然后再在适当的时间点将脏页数据写入磁盘的表空间中。这种策略称为 <code>WAL (Write Ahead Log)</code> 预写日志策略。</p> <p>这样一旦内存崩溃了，MySQL 重启之后，也可以从 <code>redo log</code> 中重新加载回事务的数据到内存中，实现了数据的持久化，保证了数据的可靠性。</p> <p><code>redo log buffer</code> 的默认大小为16Mb，Innodb 存储引擎先将重做日志写入 <code>redo log buffer</code>中，然后会通过以下三种方式将 Innodb 日志缓冲区的日志刷新到磁盘：</p> <ul><li>Master Thread 每秒一次执行刷新 <code>Innodb_log_buffer</code> 到重做日志文件</li> <li>每个事务提交时会刷新。</li> <li>当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件。</li></ul> <p>因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。</p> <h2 id="innodb-的磁盘结构"><a href="#innodb-的磁盘结构" class="header-anchor">#</a> InnoDB 的磁盘结构</h2> <p>InnoDB 磁盘分为共享表空间和用户表空间，表的数据和索引等信息都会存入这两个表空间中。</p> <h3 id="共享表空间"><a href="#共享表空间" class="header-anchor">#</a> 共享表空间</h3> <p><code>InnoDB</code> 系统表空间包括了：</p> <ul><li>数据字典(data dictionary)：记录数据库相关信息</li> <li>doublewrite write buffer：解决部分写失败（页断裂）</li> <li>insert buffer：内存insert buffer数据，周期写入共享表空间，防止意外宕机</li> <li>回滚段(rollback segments)</li> <li>undo空间：undo页</li></ul> <p>共享表空间默认只有一个文件组成，初始化大小为 <code>10MB</code> ，名称是 <code>ibdata1</code>，被创建在 mysql 的数据目录下，可以通过参数 <code>innodb_data_file_path</code> 对文件的数量和大小进行修改：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment">-- 格式：innodb_data_file_path=datafile1[,datafile2]...</span>
innodb_data_file_path <span class="token operator">=</span> <span class="token operator">/</span>db<span class="token operator">/</span>ibdata1:<span class="token number">1000</span>M<span class="token punctuation">;</span><span class="token operator">/</span>dr2<span class="token operator">/</span>db<span class="token operator">/</span>ibdata2:<span class="token number">1000</span>M:autoextend
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这里就指定了共享表空间是两个文件 <code>ibdata1</code> 和 <code>ibdata2</code> , 并且指定了大小是 <code>1000M</code> ，还指定了属性 <code>autoextend</code> ,当表空间满了的时候会自动扩展。</p> <h3 id="用户表空间"><a href="#用户表空间" class="header-anchor">#</a> 用户表空间</h3> <p>当设置了参数 <code>innodb_file_per_table</code> 时，还可以为每个基于 <code>innodb</code> 存储引擎的表产生一个单独的用户表空间，命名规则是 <code>.ibd</code></p> <p>这样子就不用将所有的数据都存放到共享表空间中，不过用户表空间也只会存储该表的数据、索引和插入缓冲等信息，其他信息例如元数据之类的还是存放在共享表空间中。</p> <h2 id="事务持久化实现机制"><a href="#事务持久化实现机制" class="header-anchor">#</a> 事务持久化实现机制</h2> <p><code>InnoDB</code> 对于数据文件和日志文件的刷盘遵守 <code>WAL(Write ahead redo log)</code> 和 <code>Force-log-at-commit</code> 两种规则，二者保证了事务的持久性。</p> <ul><li><code>WAL</code> 要求数据的变更写入到磁盘前，首先必须将内存中的日志写入到磁盘；</li> <li><code>Force-log-at-commit</code> 要求当一个事务提交时，所有产生的日志都必须刷新到磁盘上。</li></ul> <p>这样如果日志刷盘成功后，就算缓冲池中的数据在落盘前宕机了，那么重启时，数据库可以从日志中恢复数据到表空间中。</p> <p>下面先研究下到底是如何将数据从 <code>buffer pool</code> 落盘到重做日志中的。首先看下面图的右边部分：</p> <p><img src="/mysql_img/redologluopan.png" alt="s"></p> <p>当执行 <code>commit</code> 语句后（还有另外两种机制，上面写了），数据会从 <code>buffer pool</code> 中会生成一个 <code>redo page</code> 然后写入到 <code>redo log buffer</code> 中,然后通过某种落盘机制，将事务的数据写入到 <code>redo log file</code> 中，使它真正落盘。</p> <p>这一系列操作称为 <code>Force Log at Commit</code> , 它就是实现事务的持久性的一份子，<strong style="color:#3EAF7C;">即当事务提交的时候，必须先将数据写入到 <code>redo log file</code> 中，这个事务才算提交完成</strong>。</p> <p>另外，操作系统的文件系统是带有缓存的，当<code>InnoDB</code>向磁盘写入数据时，有可能只是写入到了文件系统的缓存中，没有真正的“落袋为安”。其流程如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>redo log buff ---mysql 工作线程写 (write)---&gt; redo log file ---OS刷新 (flush)---&gt; disk
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>是否需要马上写入到文件而不是缓存中，就是下面要介绍的落盘机制了，这个机制体现了 <code>Force log at commit</code>。</p> <h3 id="重做日志落盘机制"><a href="#重做日志落盘机制" class="header-anchor">#</a> 重做日志落盘机制</h3> <p><code>redo log</code> 的落盘机制有三种，主要通过 <code>innodb_flush_log_at_trx_commit</code> 来控制，对应的值分别是 <code>0</code>、<code>1（默认）</code>、<code>2</code>，可以通过以下命令查询：</p> <p><img src="/mysql_img/redodefault.png" alt="img"></p> <p>这三个值之间的区别如下：</p> <ul><li>当它是 <code>0</code> 时，代表每次事务提交时，只会先将数据从 <code>buffer pool</code> 写入到 <code>redo buffer</code> 就不管了，后面每个一个时间（通常是 1 秒）会由子线程负责将它写入到操作系统文件缓存中并 <code>flush</code> 到磁盘上。<strong style="color:#3EAF7C;">因此，这种方式的效率最高，但是数据可靠性最低，如果在系统崩溃前还没写入 <code>redo log file</code> 的话，重启后数据就丢失了。</strong></li> <li>当它是 <code>1</code> 时，代表每次事务提交时，会直接将数据写到操作系统文件缓存中并立即刷新到磁盘上。<strong style="color:#3EAF7C;">这个级别的可以确保每次事务提交数据都会写入磁盘上，数据可靠性高。但是写入效率最低</strong></li> <li>当它是 <code>2</code> 时，代表每次事务提交时，会先将数据写入到操作系统文件缓存中，后面等操作系统自己决定什么时候再写入磁盘上。写入效率和可靠性差不多水平。</li></ul> <p>图示如下：</p> <p><img src="/mysql_img/redofall.jpg" alt="sd"></p> <h3 id="双写机制"><a href="#双写机制" class="header-anchor">#</a> 双写机制</h3> <p>单单靠 <code>redo log file</code> 仅仅能保证日志的持久性，现在内存中的脏页数据还没有被持久化到共享表空间和用户表空间中。这就是上面图的左边了，由 <code>buffer pool</code> 进行落盘到表空间。</p> <p>这里的落盘同样有一种策略，称为 <code>double write</code> 双写策略。这种策略解决了什么问题呢？首先需要知道：</p> <ol><li>数据库IO的最小单位是16K（MySQL默认，oracle是8K）</li> <li>文件系统IO的最小单位是4K（也有1K的）</li> <li>磁盘IO的最小单位是512字节</li></ol> <p>也就是说，从 <code>buffer pool</code> 写入磁盘上的页至少需要四次物理IO操作，一次写入4K，但是这样有可能会出意外，如果写入了两次的时候，系统断电了，那么这个页就没写完整，称为页断裂。</p> <p>因此需要双写机制，当触发系统中设置的脏页落盘机制时：</p> <ol><li>首先将 <code>buffer pool</code> 的脏页数据通过<code>memcpy</code>函数写入到 <code>double write pool</code> 中，然后每次取 <code>2M</code> 出来</li> <li>接着会<strong style="color:#3EAF7C;">分两次从<code>double write pool</code>读取<code>1M</code>的数据写入到共享表空间中，然后马上调用fsync函数，同步磁盘，避免操作系统缓冲写带来的问题。这里是顺序IO写入，速度很快</strong></li> <li>第二步完成后，再将 <code>buffer write pool</code> 中的脏页数据写入对应的用户表空间，这里是随机IO,速度较慢，<strong style="color:#3EAF7C;">这一步写完后，就会标记对应的 <code>double wrtie</code> 可以被覆盖。</strong></li></ol> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>共享表空间即 ibdata,是磁盘是连续128个页，也是2M的大小。</p></div> <h3 id="双写机制的作用"><a href="#双写机制的作用" class="header-anchor">#</a> 双写机制的作用</h3> <p>前面说到，由于磁盘IO限制的原因，写入用户表空间的时候，可能会发生页断裂的情况，但如果我们先将这些写入共享表空间，这样当在写入用户表空间的时候，即使宕机了，<strong style="color:#3EAF7C;">重启之后也可以从共享表空间中的<code>double write</code>区域找到该页最近的版本</strong>，从而恢复到用户表空间中。</p> <p>那有人可能会问说，那 <code>redo log</code> 不也记录了脏页数据吗，怎么不用它来恢复呢？这是因为 <code>redo log</code> 记录的其实是数据的变化，而不是记录一整个页。例如，存在一个<code>test</code>数据文件的第1025个数据块的100字节的偏移位置，数据修改为了<code>new data</code>，<strong style="color:#3EAF7C;">这时候<code>read log</code>记录的就是这个偏移位置修改了数据为 <code>new data</code>，而不是记录整个 16KB 的页。</strong></p> <p>因此，<code>redo log</code> 中的数据也是零散的，是无法回复完整的页的，这就是双写的作用。</p> <p>即使在写入共享表空间时宕机了，由于 <code>redo log</code> 已经被写入了，这样重启的时候，<code>buffer pool</code> 中的数据也是可以从 <code>redo log</code> 中恢复到内存中的，从而可以重新执行 <code>double write</code>。</p> <h3 id="双写机制的策略"><a href="#双写机制的策略" class="header-anchor">#</a> 双写机制的策略</h3> <p>上面讲到，<code>double write</code> 只有在触发系统设置的数据页落盘机制时，才会执行。这里就要讲一下这个落盘机制是什么？这个机制称为<strong style="color:#3EAF7C;">检查点 check point，它表示脏页需要写入磁盘的时机，一旦触发了检查点，就是需要刷新脏页数据到磁盘的时候了。</strong></p> <p>检查点的作用是：</p> <ul><li>为数据可靠性做保证，缩短数据库的恢复时机</li> <li>当 <code>buffer pool</code> 空间快不足的时候，将脏页刷入磁盘中</li> <li>当 <code>redo log buffer</code> 快满的时候，刷新脏页到磁盘。</li></ul> <p>检查点有几种，分别是：</p> <ul><li><code>sharp checkpoint</code></li> <li><code>fuzzy checkpoint</code> <ul><li><code>master thread checkpoint</code></li> <li><code>flush_lru_list checkpoint</code></li> <li><code>async/sync flush checkpoint</code></li> <li><code>dirty page too much checkpoint</code></li></ul></li></ul> <h3 id="sharp-checkpoint"><a href="#sharp-checkpoint" class="header-anchor">#</a> sharp checkpoint</h3> <p>这个是完全检查点，只有当数据库完全关闭的时候，才会触发将所有的脏页写入磁盘中。</p> <h3 id="fuzzy-checkpoint"><a href="#fuzzy-checkpoint" class="header-anchor">#</a> fuzzy checkpoint</h3> <p>这个是模糊检查点，根据不同的设置触发脏页落盘。</p> <h4 id="master-thread-checkpoint"><a href="#master-thread-checkpoint" class="header-anchor">#</a> master thread checkpoint</h4> <p>主线程检查点，将会以每秒或者每十秒，从缓冲池的脏页中刷一定比例的页回磁盘，并且这个过程是异步的，由其它线程完成。</p> <h4 id="flush-lru-list-checkpoint"><a href="#flush-lru-list-checkpoint" class="header-anchor">#</a> flush_lru_list checkpoint</h4> <p>LRU 检查点，这里使用的 <code>LRU</code> 最近最少使用算法，将最近最少使用的脏页数据刷新到磁盘中。</p> <h4 id="async-sync-flush-checkpoint"><a href="#async-sync-flush-checkpoint" class="header-anchor">#</a> async/sync flush checkpoint</h4> <p>异步/同步刷盘检查点，当 <code>redo log file</code> 快满的时候，会批量的触发数据页落盘。</p> <ul><li>当不可覆盖的 <code>redo log</code> 达到 <code>log file</code> 的 75%，将会异步刷盘</li> <li>当不可覆盖的 <code>redo log</code> 达到 <code>log file</code> 的 90%，将会同步由主线程刷盘，此时 mysql 啥都不能做</li></ul> <h4 id="dirty-page-too-much-checkpoint"><a href="#dirty-page-too-much-checkpoint" class="header-anchor">#</a> dirty page too much checkpoint</h4> <p>脏页过多检查点，当 <code>buffer pool</code> 快满的时候，也就是脏页过多的时候，这个过多大概是 75% ，就会触发刷盘。</p> <h2 id="事务隔离性实现机制"><a href="#事务隔离性实现机制" class="header-anchor">#</a> 事务隔离性实现机制</h2> <p>下面讲解一下 Mysql 事务中的隔离性在 <code>innodb</code> 中是如何实现的</p> <h3 id="隔离级别介绍"><a href="#隔离级别介绍" class="header-anchor">#</a> 隔离级别介绍</h3> <p>首先介绍一下隔离级别，在事务中，一共有四种隔离级别，分别是：</p> <ul><li><strong style="color:#3EAF7C;">读未提交（Read uncommitted）</strong>: 事务 A 可以读到事务 B 还没提交的数据</li> <li><strong style="color:#3EAF7C;">读已提交（Read committed）</strong>：事务 A 只能读到事务 B 已经提交的数据</li> <li><strong style="color:#3EAF7C;">可重复读（Repeatable read）</strong>：事务 A 执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li> <li><strong style="color:#3EAF7C;">串行化（Serializable）</strong>：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</li></ul> <h3 id="各个隔离级别的问题"><a href="#各个隔离级别的问题" class="header-anchor">#</a> 各个隔离级别的问题</h3> <p>首先阅读以下案例，假设除了用户A和用户B之外，其他用户的存款总额都为0，A、B用户各有存款1000，所以所有用户的存款总额为2000。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment">--创建账户表并初始化数据</span>
<span class="token keyword">create</span> <span class="token keyword">table</span> tacount<span class="token punctuation">(</span>id <span class="token keyword">int</span> <span class="token punctuation">,</span> aname <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>acount <span class="token keyword">int</span> <span class="token punctuation">,</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">alter</span> <span class="token keyword">table</span> tacount <span class="token keyword">add</span> <span class="token keyword">index</span> idx_name<span class="token punctuation">(</span>aname<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> tacount <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> tacount <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>首先演示在<code>读未提交 RU</code>隔离级别下存在的问题，首先设置隔离级别为 <code>RU</code>：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment">--设置隔离级读未提交（read-uncommitted）</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">set</span> <span class="token keyword">session</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token keyword">read</span> <span class="token keyword">uncommitted</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>session1</code> 首先启动事务，开始查询 <code>a</code> 的余额为 1000，然后 <code>session2</code> 从账户 <code>b</code> 划100块给 <code>a</code>。此时，<code>session1</code> 再次查询账户 <code>a</code> 的余额就是 1100 了，假如此时 <code>session2</code> 发生了异常，回滚了数据，那么此时 <code>session1</code> 读到的数据就是错误的。<strong style="color:#3EAF7C;">这就是脏读，读到了另一个事务还没提交的数据。</strong></p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment">--session 1</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">start</span> <span class="token keyword">transaction</span> <span class="token punctuation">;</span> 
       <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tacount <span class="token keyword">where</span> aname<span class="token operator">=</span><span class="token string">'a'</span><span class="token punctuation">;</span>
        <span class="token operator">+</span><span class="token comment">----+-------+--------+</span>
        <span class="token operator">|</span> id <span class="token operator">|</span> aname <span class="token operator">|</span> acount <span class="token operator">|</span>
        <span class="token operator">+</span><span class="token comment">----+-------+--------+</span>
        <span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> a   <span class="token operator">|</span>  <span class="token number">1000</span> <span class="token operator">|</span>
        <span class="token operator">+</span><span class="token comment">----+-------+--------+</span>
<span class="token comment">--session 2</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span> 
       <span class="token keyword">update</span> tacount <span class="token keyword">set</span> acount<span class="token operator">=</span><span class="token number">1100</span> <span class="token keyword">where</span> aname<span class="token operator">=</span><span class="token string">'b'</span><span class="token punctuation">;</span>
<span class="token comment">--session 1</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tacount <span class="token keyword">where</span> aname<span class="token operator">=</span><span class="token string">'b'</span><span class="token punctuation">;</span>
       <span class="token operator">+</span><span class="token comment">----+-------+--------+</span>
       <span class="token operator">|</span> id <span class="token operator">|</span> aname <span class="token operator">|</span> acount <span class="token operator">|</span>
       <span class="token operator">+</span><span class="token comment">----+-------+--------+</span>
       <span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> b   <span class="token operator">|</span>  <span class="token number">1100</span> <span class="token operator">|</span>
       <span class="token operator">+</span><span class="token comment">----+-------+--------+</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>可以看到，在<code>读未提交</code>的隔离级别下，并发得不到任何的保障，因此可以将隔离级别设置为 <code>Serialization</code> 序列化级别。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment">--设置隔离级别为串行化（serializable） 死锁演示</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">set</span> <span class="token keyword">session</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token keyword">serializable</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在这个隔离级别下，读一条记录会加读锁，写一条记录会加写锁，这样当事务 A 读取一行记录的时候，其他事务都不能对该记录进行修改操作，从而保证可靠性，<strong style="color:#3EAF7C;">这种通过锁机制保证并发的策略称为 <code>Locking-Base CC</code></strong>，但是这样会存在另一个问题，那就是<strong style="color:#3EAF7C;">死锁</strong>。</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token comment">-- session1</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span>
       <span class="token comment">-- 给记录 a 加锁</span>
       <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tacount <span class="token keyword">where</span> aname <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span> 
<span class="token comment">-- session2</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span>
       <span class="token comment">-- 给记录 b 加锁了</span>
       <span class="token keyword">update</span> tacount <span class="token keyword">set</span> acount<span class="token operator">=</span><span class="token number">1100</span> <span class="token keyword">where</span> aname<span class="token operator">=</span><span class="token string">'b'</span><span class="token punctuation">;</span> 
<span class="token comment">-- session1</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span>
       <span class="token comment">-- 堵塞了，因为 b 现在被 session2 锁住中</span>
       <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tacount <span class="token keyword">where</span> aname <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">;</span> 
<span class="token comment">-- session2</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span>
       <span class="token comment">-- 堵塞了，因为 a 现在被 session1 锁住中</span>
       <span class="token keyword">update</span> tacount <span class="token keyword">set</span> acount<span class="token operator">=</span><span class="token number">900</span> <span class="token keyword">where</span> aname<span class="token operator">=</span><span class="token string">'a'</span><span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>这时就需要另外一种机制，让它既可以支持并发，又可以保证事务不会读到未提交的事务，这种机制就是 <code>MVCC</code> 多版本并发控制。这种机制在执行普通 <code>select</code> 操作时不会加锁，提高了数据库的并发处理能力。</p> <h3 id="mvcc-实现"><a href="#mvcc-实现" class="header-anchor">#</a> MVCC 实现</h3> <blockquote><p>58沈剑大佬：<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961444&amp;idx=1&amp;sn=830a93eb74ca484cbcedb06e485f611e&amp;chksm=bd2d0db88a5a84ae5865cd05f8c7899153d16ec7e7976f06033f4fbfbecc2fdee6e8b89bb17b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">为什么需要 MVCC<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，讲解了数据多版本和普通锁以及行读锁之间的区别。</p></blockquote> <p><code>MVCC</code> 全称是 <code>Multiversion concurrency control</code>, 多版本并发控制。具体通过 <code>undo log</code> 和 <code>read view</code> 来实现的。</p> <h3 id="undo-log"><a href="#undo-log" class="header-anchor">#</a> Undo Log</h3> <p><code>undo log</code> 即回滚日志，主要用于对事务进行回滚撤销以及用于在多版本并发控制提供历史版本。它记录了每个操作之前的状态，如果事务需要回滚，则根据 <code>undo log</code> 进行回滚。</p> <p><code>undo log</code> 的存储不同于 <code>redo log</code> , 后者存的是单独的文件中，而前者是存放在共享表空间中的一个特殊的段，这个段叫做<code>回滚段</code>，在段中存放着一个个的区（Extent），每个区里面就是有很多个页，在回滚段里就是 <code>undo page</code>。这个 <code>page</code> 和普通的数据页以及索引页类似。</p> <p><img src="/mysql_img/undopage.jpg" alt="mysql"></p> <p>页里存放着每一行的数据，格式如下，其中前面是那三个字段分别对应该行的<code>rowid</code>、事务号<code>db_trx_id</code>和回滚指针<code>db_roll_ptr</code>，其中<strong style="color:#3EAF7C;"><code>db_trx_id</code>表示最近修改的事务的id，<code>db_roll_ptr</code>指向<strong>回滚段中的<code>undo log</code></strong>。</strong></p> <p><img src="/mysql_img/undorow.png" alt="ds"></p> <p>由于 <code>redo log</code> 会记录数据库中页的物理修改操作，而 <code>undo log</code> 也属于其中的一份子，因此也会被记录到 <code>redo log</code> 中,结合之前讲的，当执行一个 <code>update</code> 事务时，完整的流程图如下：</p> <p><img src="/mysql_img/undotransacrtion.png" alt="myg"></p> <p>当执行 <code>update</code> 加锁后，会先生成<code>undo log</code> 的 <code>redo log</code> 以及 <code>undo log</code> 数据 记录到 <code>redo log buffer</code> 中，然后再记录数据变更相关的 <code>redo log</code> 到缓冲中，最后才在内存中更新数据，形成脏页。<strong style="color:#3EAF7C;">注意，此时事务仍然还未提交。</strong></p> <ul><li><code>undo log</code> 的 <code>redo log</code> 是记录了 <code>undo log</code> 产生了哪些变化，防止mysql崩溃了导致 <code>undo log</code> 的变更丢失，失去了可靠性。</li> <li><code>undo log</code> 就是记录了一个回滚操作，当事务提交之后是需要删除的，但是删除的时机需要由 <code>purge</code> 线程决定。</li></ul> <p>如果在执行 <code>commit</code> 之前宕机了，由于 <code>redo log</code> 触发落盘的机制有三种，因此就算没 <code>commit</code>, <code>redo log</code> 中也是会有数据的，所以可以检查 <code>redo log</code> 中的日志来恢复数据和 <code>undo log</code> 。</p> <p>如果在执行 <code>commit</code> 之后，redo 落盘完成了，此时触发脏页落盘表空间时宕机了，则启动后直接从 <code>redo log</code> 中恢复数据即可。</p> <p><strong style="color:#3EAF7C;">注意，这是所说的恢复数据是指恢复到表空间中，而不是内存</strong></p> <h3 id="事务链表"><a href="#事务链表" class="header-anchor">#</a> 事务链表</h3> <p>有了 <code>undo log</code> 后，就可以实现数据的多版本了，下面来讲一讲 <code>RC</code> 和 <code>RR</code> 级别下是如何受到 <code>MVCC</code> 的管控，从而实现了事务的隔离性，使得 <code>RC</code> 防止了脏数据和<code>RR</code>防止了不可重复读。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>另外，<code>RR</code> 还通过间隙锁防止了幻读，可通过<code>MySQL 锁</code>查阅。</p></div> <p>其实啊，每个事务在启动的时候，会给自己生成一个事务 Id，同时也会记录当前正在活跃的所有事务的id，即当前所有未提交的事务id，保存在一个叫<code>trx_sys</code>的事务链表中，并且把数组里面事务 ID 的最小值记为低水位 <code>up_limit_id</code> ，当前系统里面<strong style="color:#3EAF7C;">已经创建过的事务 ID 的最大值加 1 </strong>记为高水位 <code>low_limit_id</code>。</p> <p>这是一个基本的链表结构：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>-- ctx 是当前事务 id，是最大的
ct-trx --&gt; trx11 --&gt; trx9 --&gt; trx6 --&gt; trx5 --&gt; trx3;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这个视图数组和高水位，就形成了当前事务的一致性视图 <code>read-view</code>。</p> <p>前面提到，开启事务有二种方式：</p> <ul><li><code>begin</code> 或 <code>start transaction</code></li> <li><code>start transaction with consistent snapshot</code></li></ul> <p>其中这两种方式的区别其实就是<strong style="color:#3EAF7C;">在什么时候才确定好这个事务链表的值</strong>。</p> <ul><li>第一种方式启动的事务，会在第一次执行 SQL 语句的时候才确定好事务链表。</li> <li>第二种方式启动的事务，会在执行完事务开启语句后就确定好事务链表了。</li></ul> <p>并且 <code>RR</code> 和 <code>RC</code> 的区别就是：</p> <ul><li>在可重复读隔离级别下，事务链表一旦创建了直到事务提交之前，都不会发生变化</li> <li>在读已提交隔离级别下，每次执行<code>SQL</code>语句都会重新创建事务链表。</li></ul> <div class="custom-block tip"><p class="custom-block-title">注意</p> <p>每当活跃的事务提交了之后，就会从事务链表之间移除，所以在 <code>RC</code> 隔离级别下，每次执行 SQL 语句得到的事务链表可能都不一样。</p></div> <p>可以通过 <code>show engine innodb status</code> ,就能够看到事务列表。</p> <h3 id="read-view"><a href="#read-view" class="header-anchor">#</a> read view</h3> <p>上面说到，这个事务链表包含的这些事务 ID，就是当前事务的<code>read view</code>，其图示大概如下：</p> <p><img src="/mysql_img/uplow.png" alt="my"></p> <p>其中</p> <ul><li><strong style="color:#3EAF7C;">比低水位还小的那些事务，都是已经提交了的事务</strong>，对于当前事务来说，是可见，也就是图中的绿色区域</li> <li><strong style="color:#3EAF7C;">比高水位还高的那些事务，属于未来的还没开启的事务</strong>，对于当前事务来说，是不可见的，即红色区域</li> <li>而在黄色区域中的数据，对于不同的隔离级别有不同的情况
<ul><li><strong style="color:#3EAF7C;">如果在 <code>RR</code> 级别下，由于事务链表从启动后就不会改变，因此如果读到的数据还是处于链表内的数据，也是不可见的</strong></li> <li><strong style="color:#3EAF7C;">如果在 <code>RC</code> 级别下，由于每次执行SQL链表都会改变，如果执行<code>SQL A</code>时，链表内有四个事务，执行<code>SQL B</code>的时候，可能就剩三个事务了</strong>，因此就会存在在读取数据的时候，发现这个事务的 Id 在链表的范围内，却不在链表内，因此是可见的，因为这个事务是已经提交了的。</li></ul></li></ul> <h3 id="mvcc-的运作流程"><a href="#mvcc-的运作流程" class="header-anchor">#</a> MVCC 的运作流程</h3> <p>案例介绍：</p> <div class="language-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t<span class="token punctuation">`</span> <span class="token punctuation">(</span> 
  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> 
  <span class="token punctuation">`</span>k<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> 
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> t<span class="token punctuation">(</span>id<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>假设现有三个事务 A、B、C，它们之间的顺序如下：</p> <p><img src="/mysql_img/demo.png" alt="my"></p> <p>假设</p> <ol><li>事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；</li> <li>事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；</li> <li>三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。</li></ol> <p>下面分析下，A和B在不同的 <code>RR</code> 和 <code>RC</code> 隔离级别下会读到什么值，首先分析在 <code>RR</code> 级别下：</p> <ol><li>事务 A 的 <code>read view</code> 是 <code>[99,100]</code></li> <li>事务 B 的 <code>read view</code> 是 <code>[99,100,101]</code></li> <li>事务 C 的 <code>read view</code> 是 <code>[90,100,101,102]</code></li></ol> <p>当事务 A 执行查询语句的时候，事务 C 和 B 的更改都已经做好了，并且 C 已提交，B未提交：</p> <ol><li>此时会先查询到 B 的记录，对于事务 B 的 <code>trxid</code> ,发现处于高水位位置，因此是不可见的，<strong style="color:#3EAF7C;">这时候读取这条记录的回滚指针，到回滚段中找到上一条记录</strong></li> <li>也就是事务 C 修改的数据，发现事务C的<code>trxid</code> 是 102，也是高水位，因此同样是不可见的。</li> <li>最后通过事务 C 的回滚指针找到事务id为90的数据，所以最终事务 A 读到的数据是 <code>1，1</code></li></ol> <p>如果在 <code>RC</code> 级别下，由于每次执行SQL前都会更新视图数据，所以每次读取都相当于是只会读取到已提交事务的数据，所以事务 A 读到的就是事务 C 修改过的数据。</p> <p>总结的说，一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p> <ul><li>版本未提交，不可见；</li> <li>版本已提交，但是是在视图创建后提交的，不可见；</li> <li>版本已提交，而且是在视图创建前提交的，可见。</li></ul> <h3 id="快照读和当前读"><a href="#快照读和当前读" class="header-anchor">#</a> 快照读和当前读</h3> <p>这种读取到历史版本数据的查询，称为<strong style="color:#3EAF7C;">快照读</strong>，也叫做<strong style="color:#3EAF7C;">一致性非锁定读</strong>。</p> <p>与<strong style="color:#3EAF7C;">快照读</strong>对应的是<strong style="color:#3EAF7C;">当前读</strong>，也就是图中事务 B 的流程，当事务 B 在执行 <code>update</code> 语句时，需要先读取数据到内存中，再进行修改。</p> <p>这个读取必须是读取当前最新的版本数据，因为在历史版本数据上修改没有任何意义。因此这种读取最新数据的行为就叫做<strong style="color:#3EAF7C;">当前读</strong>。</p> <p>然后当事务 B 后面执行查询语句的时候，读取到最新版本的修改时，发现事务id是自己的，所以就直接读取自己最新的记录了。</p> <p>另外，如果给 <code>select</code> 语句加上 <code>share in lock mode</code> 或 <code>for update</code> 也是当前读。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/database/RDB/MySQL_Learn/MySQL锁.html" class="prev">
        MySQL 锁
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.78cba7d9.js" defer></script><script src="/assets/js/2.b97de27f.js" defer></script><script src="/assets/js/6.bb2aa06c.js" defer></script>
  </body>
</html>
