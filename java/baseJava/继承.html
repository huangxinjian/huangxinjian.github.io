<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>继承 | HuangXinJian</title>
    <meta name="description" content="If you learn, learn deeply please!">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="icon" href="/H.png">
    
    <link rel="preload" href="/assets/css/0.styles.77838d5e.css" as="style"><link rel="preload" href="/assets/js/app.78cba7d9.js" as="script"><link rel="preload" href="/assets/js/2.b97de27f.js" as="script"><link rel="preload" href="/assets/js/31.4bc393d7.js" as="script"><link rel="prefetch" href="/assets/js/10.5a39f9cf.js"><link rel="prefetch" href="/assets/js/11.fc6bddf2.js"><link rel="prefetch" href="/assets/js/12.da1eaab3.js"><link rel="prefetch" href="/assets/js/13.3e791f4e.js"><link rel="prefetch" href="/assets/js/14.5953a388.js"><link rel="prefetch" href="/assets/js/15.b9e792e3.js"><link rel="prefetch" href="/assets/js/16.14be3228.js"><link rel="prefetch" href="/assets/js/17.d8c48abe.js"><link rel="prefetch" href="/assets/js/18.c1171d86.js"><link rel="prefetch" href="/assets/js/19.687638f3.js"><link rel="prefetch" href="/assets/js/20.dbb7c712.js"><link rel="prefetch" href="/assets/js/21.fcac9d7b.js"><link rel="prefetch" href="/assets/js/22.05c89a82.js"><link rel="prefetch" href="/assets/js/23.6f455ef9.js"><link rel="prefetch" href="/assets/js/24.a5f5dd42.js"><link rel="prefetch" href="/assets/js/25.ddacf5f1.js"><link rel="prefetch" href="/assets/js/26.1dbabccd.js"><link rel="prefetch" href="/assets/js/27.4d3ddddd.js"><link rel="prefetch" href="/assets/js/28.aca93b2e.js"><link rel="prefetch" href="/assets/js/29.4e592fcf.js"><link rel="prefetch" href="/assets/js/3.8c3b122e.js"><link rel="prefetch" href="/assets/js/30.07e05cf0.js"><link rel="prefetch" href="/assets/js/32.5bed9ede.js"><link rel="prefetch" href="/assets/js/33.b1d61159.js"><link rel="prefetch" href="/assets/js/34.27c7f1f1.js"><link rel="prefetch" href="/assets/js/35.17c92a26.js"><link rel="prefetch" href="/assets/js/36.91a5ecf5.js"><link rel="prefetch" href="/assets/js/37.88c250af.js"><link rel="prefetch" href="/assets/js/38.6d72295b.js"><link rel="prefetch" href="/assets/js/39.0e585af1.js"><link rel="prefetch" href="/assets/js/4.ff5f2a88.js"><link rel="prefetch" href="/assets/js/40.80a7f1c2.js"><link rel="prefetch" href="/assets/js/41.defa3efa.js"><link rel="prefetch" href="/assets/js/42.70857ada.js"><link rel="prefetch" href="/assets/js/5.68065b24.js"><link rel="prefetch" href="/assets/js/6.bb2aa06c.js"><link rel="prefetch" href="/assets/js/7.f469350c.js"><link rel="prefetch" href="/assets/js/8.37ca51cf.js"><link rel="prefetch" href="/assets/js/9.68f4fa83.js">
    <link rel="stylesheet" href="/assets/css/0.styles.77838d5e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">HuangXinJian</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="NodeJS" class="dropdown-title"><span class="title">NodeJS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/nodejs/NodeJS基础/NodeJS介绍.html" class="nav-link">
  NodeJS 基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java/baseJava/Java 介绍.html" class="nav-link">
  Java 基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分布式" class="dropdown-title"><span class="title">分布式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/distributed/frameworkHistory/架构演变历史.html" class="nav-link">
  分布式学习路线
</a></li><li class="dropdown-item"><!----> <a href="/distributed/registerCenter/" class="nav-link">
  注册中心
</a></li><li class="dropdown-item"><!----> <a href="/distributed/messageSystem/" class="nav-link">
  消息系统
</a></li><li class="dropdown-item"><!----> <a href="/distributed/internal/" class="nav-link">
  网络框架
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          关系型数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/database/RDB/MySQL_Learn/MySQL安装.html" class="nav-link">
  MySQL
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="https://github.com/huangxinjian/huangxinjian.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="NodeJS" class="dropdown-title"><span class="title">NodeJS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/nodejs/NodeJS基础/NodeJS介绍.html" class="nav-link">
  NodeJS 基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/java/baseJava/Java 介绍.html" class="nav-link">
  Java 基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分布式" class="dropdown-title"><span class="title">分布式</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/distributed/frameworkHistory/架构演变历史.html" class="nav-link">
  分布式学习路线
</a></li><li class="dropdown-item"><!----> <a href="/distributed/registerCenter/" class="nav-link">
  注册中心
</a></li><li class="dropdown-item"><!----> <a href="/distributed/messageSystem/" class="nav-link">
  消息系统
</a></li><li class="dropdown-item"><!----> <a href="/distributed/internal/" class="nav-link">
  网络框架
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          关系型数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/database/RDB/MySQL_Learn/MySQL安装.html" class="nav-link">
  MySQL
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="https://github.com/huangxinjian/huangxinjian.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/java/baseJava/Java 介绍.html" class="sidebar-link">Java 介绍</a></li><li><a href="/java/baseJava/对象与类.html" class="sidebar-link">面向对象</a></li><li><a href="/java/baseJava/继承.html" class="active sidebar-link">继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#超类和子类" class="sidebar-link">超类和子类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#方法重写" class="sidebar-link">方法重写</a></li><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#super-关键字" class="sidebar-link">super 关键字</a></li><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#子类构造器" class="sidebar-link">子类构造器</a></li><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#多态" class="sidebar-link">多态</a></li><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#继承下的方法调用" class="sidebar-link">继承下的方法调用</a></li><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#方法表" class="sidebar-link">方法表</a></li><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#强制类型转换" class="sidebar-link">强制类型转换</a></li><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#抽象类" class="sidebar-link">抽象类</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#祖先类-object" class="sidebar-link">祖先类 Object</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#equals-方法" class="sidebar-link">equals 方法</a></li><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#完美的-equals-编写方法" class="sidebar-link">完美的 equals 编写方法</a></li><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#数组的比较" class="sidebar-link">数组的比较</a></li><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#hashcode-方法" class="sidebar-link">hashCode 方法</a></li><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#tostring-方法" class="sidebar-link">toString 方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#对象包装器和自动装箱" class="sidebar-link">对象包装器和自动装箱</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#自动装箱" class="sidebar-link">自动装箱</a></li><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#自动拆箱" class="sidebar-link">自动拆箱</a></li><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#integer-的秘密" class="sidebar-link">Integer 的秘密</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#枚举类" class="sidebar-link">枚举类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/baseJava/继承.html#enum-类" class="sidebar-link">Enum 类</a></li></ul></li></ul></li><li><a href="/java/baseJava/反射.html" class="sidebar-link">反射</a></li><li><a href="/java/baseJava/接口和Lambda和内部类.html" class="sidebar-link">接口和Lambda和内部类</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h1> <p>继承是面向对象的另一个基本概念，通过继承，<strong style="color:#3EAF7C;">可以基于一个已存在的类来创建一个新类，从而可以复用已存在的类的域和方法，同时可以添加新的域和方法。</strong></p> <h2 id="超类和子类"><a href="#超类和子类" class="header-anchor">#</a> 超类和子类</h2> <p>在 Java 中，一个类如果想要继承另一个类，需要通过关键字 <strong style="color:#3EAF7C;">extends</strong> 来标识，例如类 A 继承类 B：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>其中，B 就是超类（super class）,也称为基类（base class）或父类（parent class），A 就是子类（sub class）,也称为派生类（derived class）或孩子类（child class）。</p> <h3 id="方法重写"><a href="#方法重写" class="header-anchor">#</a> 方法重写</h3> <p>前面说到，子类会继承来自父类的域和方法，不过如果父类的方法不符合子类的要求的话，子类是可以进行重写（Override）操作的。例如存在雇员类 Employee：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> salary<span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> salary<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>经理类继承自雇员类，并新增了一个域 <code>bonus</code> 奖金：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span><span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> bonus<span class="token punctuation">;</span>

  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setBonus</span><span class="token punctuation">(</span><span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>bonus <span class="token operator">=</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>如果现在查询 <code>Manager</code> 对象的工资，应该是返回 <code>基本工资 + 奖金</code> 才是正确了，而父类提供的方法只返回了基本工资，因此我们需要在子类中对该方法进行重写：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span><span class="token punctuation">{</span>
  <span class="token comment">// 省略 bonus</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> bonus <span class="token operator">+</span> salary<span class="token punctuation">;</span>  <span class="token comment">// error，won't work!</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="custom-block danger"><p class="custom-block-title">WARNING</p> <p>但是要注意，这样子写是错误的，虽然 Manager 拥有一个名为 salary 的域，但在 Manager 类的方法中是不能直接访问 salary 域的。只有 Employee 类中的方法才可以访问！</p></div> <p>方法重写总结：</p> <ol><li>方法名称和参数列表要相同</li> <li>返回值类型需要 小于或等于父类</li> <li>访问权限要大于或等于父类</li> <li>重写时子类抛出的异常必须小于或等于父类抛出的异常</li> <li>与重载的区别： 重写属于继承，重载属于同一个类</li></ol> <h3 id="super-关键字"><a href="#super-关键字" class="header-anchor">#</a> super 关键字</h3> <p>想要在子类中调用来自父类的域，需要通过 super 关键字调用对应的方法来获取。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>注意，对于私有的域，super 关键字也不能直接通过 <code>super.salary</code> 来访问。因为 super 并不是一个对象的引用，它只是一个用来告诉虚拟机调用超类方法的特殊关键字。</p></div> <p>所以正确的重写写法是：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span><span class="token punctuation">{</span>
  <span class="token comment">// 省略 bonus</span>

  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> bonus <span class="token operator">+</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="子类构造器"><a href="#子类构造器" class="header-anchor">#</a> 子类构造器</h3> <p>在子类的构造器中，有这么一点需要注意，由于 Manager 类不能访问 Employee 的私有域，因此我们在创建 Manager 对象的时候，必须利用 Employee 的构造器来初始化这部分私有域。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token keyword">int</span> salary<span class="token punctuation">,</span> <span class="token keyword">int</span> bonus<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">super</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>bonus <span class="token operator">=</span> bonus<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>类似 <code>this</code> 调用构造器那样通过 <code>super</code> 调用父类的构造器。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>要注意的是，super() 必须位于子类构造器的第一行代码中。</p></div> <p>如果子类没有在构造器中<strong style="color:#3EAF7C;">显式</strong>的调用父类构造器，则系统会默认添加上一行 <code>super()</code> 来调用父类的无参构造器，若父类中不存在无参构造器，则编译器会报错。</p> <h3 id="多态"><a href="#多态" class="header-anchor">#</a> 多态</h3> <p>多态的特点：</p> <ol><li>多态是方法的多态，而不是属性的多态（多态与属性无关）</li> <li>多态有三个必要条件 --- （继承、方法重写、父类引用指向子类对象）</li> <li>父类引用指向子类对象后，用该父类引用调用子类重写的方法，这就是多态，父类的方法出现了多种形态</li></ol> <p>多态访问域或方法时：</p> <ol><li>父类引用访问成员变量还是父类自身的成员变量，不能访问子类的成员变量，因为多态与属性无关</li> <li>父类引用访问静态方法，还是自身的静态方法，因为静态方法与类相关，无法重写</li> <li>构造方法：先调用父类，再调用子类</li></ol> <p>父类引用指向子类对象，我们称为 向上转型，也叫自动类型转换</p> <h3 id="继承下的方法调用"><a href="#继承下的方法调用" class="header-anchor">#</a> 继承下的方法调用</h3> <p>由于存在多态，我们知道，父类引用可以指向子类对象，并且在调用方法的时候，调用的是子类的方法，那么当我们调用 <code>x.f(args)</code> 这个方法时，流程如下：</p> <ol><li>编译器查看隐式对象的类型和方法名</li> <li>检查本类和超类中函数 <code>f</code> 的所有重载方法，获取所有可能被调用的候选方法</li> <li>查看 <code>f</code> 被调用时传入的参数类型，如果存在一个与提供的参数完全匹配，就选择这个方法。</li></ol> <p>这个过程称为 <strong style="color:#3EAF7C;">重载解析</strong>。</p> <p>如果是 <code>private</code>、<code>static</code>、<code>final</code> 方法，编译器可以很快准确地知道应该调用哪个方法，这种方式称为<strong style="color:#3EAF7C;">静态绑定</strong>。</p> <p>如果采用动态绑定，则虚拟机会根据隐式参数的实际类型，去调用对应类型中的方法。</p> <h3 id="方法表"><a href="#方法表" class="header-anchor">#</a> 方法表</h3> <p>如果每次调用一个方法，都要一层层的搜索下去，会十分消耗时间，因此 Java 虚拟机预先为每个类初始化了一个方法表（method table），里面预设了每个类的方法签名以及实际调用的方法，例如：</p> <blockquote><p>此处省略 Object 的方法</p></blockquote> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Employee</span><span class="token operator">:</span>
  <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Employee</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">getSlary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Employee</span><span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token class-name">Manager</span><span class="token operator">:</span>
  <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Employee</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">getSlary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Manager</span><span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">setBonus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Manager</span><span class="token punctuation">.</span><span class="token function">setBonus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>当调用 <code>Employee e</code> 对象的 <code>getSalary()</code> 方法时：</p> <ol><li>首先虚拟机提取对象 <code>e</code> 的实际类型的方法表，它有可能是 <code>Employee</code> 或 <code>Manager</code> 或其他子类。</li> <li>然后开始在方法表中搜索对应签名的方法</li> <li>调用方法</li></ol> <h3 id="强制类型转换"><a href="#强制类型转换" class="header-anchor">#</a> 强制类型转换</h3> <p>我们知道，父类引用可以指向子类对象，这个称为自动转型。但是，子类引用不能直接指向父类引用，这是因为<strong style="color:#3EAF7C;">父类引用指向的实际类型到底是谁不清楚</strong>。</p> <p>不过如果知道父类引用实际上指向的是谁，就可以通过<strong style="color:#3EAF7C;">强制类型转换</strong>来暂时忽视对象的实际类型，使用对象的全部功能。</p> <p>例如存在这样一个数组 ：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> staffs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  staffs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  staffs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>对于 <code>staffs[0]</code> , 我们可以通过强制类型转换，将其转为 <code>Manager</code> 对象，这在运行时并不会报错，因为它本来就是该类型。但如果我们对 <code>staffs[1]</code> 也进行强转，则会报 <code>ClassCastException</code> 类型转换异常。</p> <p>所以在对要转换的对象引用的实际类型不清楚时，最好先进行类型判断：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>staffs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Manager</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Manager</span> manager <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Manager</span><span class="token punctuation">)</span>staffs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="抽象类"><a href="#抽象类" class="header-anchor">#</a> 抽象类</h3> <p>在 Java 中，通过关键字 <strong style="color:#3EAF7C;">abstract</strong> 声明抽象类。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>抽象只是针对方法的，对于一些方法不知道具体实现，或者等待各个子类实现自己的版本，就可以声明为抽象的</p></div> <p>下面来看一个抽象类的例子：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>抽象方法只需要提供方法前面即可，不需要写实现，实现交给子类来进行重写。另外，<strong style="color:#3EAF7C;">定义了抽象方法的类，一定是抽象类，但是抽象类不一定要有抽象方法！！！！！！！</strong>。</p> <p>而且，在抽象类中也可以定义实例域、实例方法、构造方法, 但是不能 new 对象, 构造方法只能通过子类的构造方法来调用，无法自己调用，例如上面的 Person 抽象类：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// abstract method</span>
  <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="祖先类-object"><a href="#祖先类-object" class="header-anchor">#</a> 祖先类 Object</h2> <p><code>Object</code> 类是所有类的祖先类，在 Java 中所有类都是通过继承它得到的。但是，在定义类的时候，并不需要通过 <code>extend Object</code> 来指定，因为如果没有默认继承别的类的话，是默认添加上该代码片段的。</p> <p>可以使用 Object 类的变量引用任意类型的对象。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">&quot;mike&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>在 Java 中，只有基本类型不是对象，其余类型均是对象，包括数组（不论是对象数组还是基本类型数组，均继承自 Object 类）</p></div> <h3 id="equals-方法"><a href="#equals-方法" class="header-anchor">#</a> equals 方法</h3> <p>Object 类中的 <code>equals</code> 方法用于比较两个对象是否相等，默认的实现是，<strong style="color:#3EAF7C;">判断两个对象是否具有相同的引用</strong>。</p> <p>一般子类如果有特殊需求，都会对 <code>equals</code> 方法进行重写，但是重写 <code>equals</code> 需要遵循下面五个原则：</p> <ul><li><strong style="color:#3EAF7C;">自反性</strong>：对于任何非空引用 x，<code>x.equals(x)</code> 应该返回 true。</li> <li><strong style="color:#3EAF7C;">对称性</strong>：对于任何非空引用 x 和 y , <code>x.equals(y)</code> 和 <code>y.equals(x)</code> 都应该返回 true</li> <li><strong style="color:#3EAF7C;">传递性</strong>：对于任何非空引用 x、y、z, 若 <code>x.equals(y)</code> 和 <code>y.equals(z)</code> 均返回 true，那么<code>x.equals(z)</code> 也应该返回 true</li> <li><strong style="color:#3EAF7C;">一致性</strong>：如果非空引用 x、y 均无变化，则反复调用 <code>x.equals(y)</code> 应返回相同的结果</li> <li>对于任意非空引用 x , 调用 <code>x.equals(null)</code> 应该返回 true</li></ul> <h4 id="instanceof-和-getclass"><a href="#instanceof-和-getclass" class="header-anchor">#</a> instanceof 和 getclass</h4> <p><code>instanceof</code> 和 <code>getClass()</code> 在 equals 方法中出现的频率比较高，但是也非常有争议，因为站在父类的角度或站在子类的角度都比较难把握该使用哪一个，例如:</p> <div class="language-java line-numbers-mode"><div class="highlight-lines"><br><br><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><br><br><br><br></div><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 首先通过 == 快速比较两个对象之间的引用</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment">// 判断 obj 是否为 null</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 判断两个对象的class 是否相等</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 判断到这里，就可以得到一个非空的 Employee 对象了</span>
    <span class="token class-name">Employee</span> other <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span><span class="token punctuation">)</span>obj<span class="token punctuation">;</span>
    <span class="token comment">// 进行域的比较</span>
    <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> other<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>当我们通过 <code>getClass</code> 方式进行判断是，如果隐式参数和显式参数不是一个类型的话，结果将返回 false。也就是说，当我们创建一个 <code>Manager</code> 对象时，如果调用 <code>m.equals(e)</code> ,得到的结果将会是 false</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>e 是 Employee 对象</p></div> <p>根据里氏替换原则，<strong style="color:#3EAF7C;">如果对每一个类型为 S 的对象 o1 ，都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o1 代换 o2 时，<strong>程序 P 的行为没有变化</strong>，那么类型 S 是类型 T 的子类型。</strong></p> <p>所以当调用 <code>m.equals(m)</code> 时，也应该得到 false 的结果才对，但是这个会返回 true。也就是说，这样会违反里氏替换原则。</p> <p>下面将 <code>getClass</code> 改为 <code>instanceof</code> ，代码如下：</p> <div class="language-java line-numbers-mode"><div class="highlight-lines"><br><br><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><br><br><br><br></div><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 首先通过 == 快速比较两个对象之间的引用</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment">// 判断 obj 是否为 null</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 判断 this 是不是 Employee 类</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Employee</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 判断到这里，就可以得到一个非空的 Employee 对象了</span>
    <span class="token class-name">Employee</span> other <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span><span class="token punctuation">)</span>obj<span class="token punctuation">;</span>
    <span class="token comment">// 进行域的比较</span>
    <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> other<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>不过这样又会存在这样一个问题，当调用 <code>e.equals(m)</code> 时，会返回 true，由于对称性要求，当调用 <code>m.equals(e)</code> 时，也必须返回 true，但是这样在语义上就错误了，因为这样 Manager 类就必须和每个 Employee 类相比较，而无法比较 Manager 特有的 <code>bonus</code> 域。</p> <p>这样的问题在 Jdk 的源码中也有存在，例如 <code>java.sql.TimeStamp</code> 类，它继承了 <code>java.util.Date</code> 类，但是 <code>util.Date</code> 在 equals 方法中使用了 <code>instanceof</code> ：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Date</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj <span class="token keyword">instanceof</span> <span class="token class-name">Date</span> <span class="token operator">&amp;&amp;</span> <span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Date</span><span class="token punctuation">)</span> obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>由于 <code>TimeStamp</code> 具有特殊的属于自身的语义，所以 <code>TimeStamp</code> 重写了 <code>equals</code> 方法：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Timestamp</span> ts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ts<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span>  <span class="token punctuation">(</span>nanos <span class="token operator">==</span> ts<span class="token punctuation">.</span>nanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在调用完 <code>super.equals()</code> 后，需要比较特殊的域 <code>nanos</code> ，才能确定是否相等，因此对于 <code>java.util.Date</code> 的其他子类来说，例如 <code>java.sql.Date</code> 类，当比较这两个类时，就会存在对称性问题：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">long</span> timeMillis <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Date</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>timeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Timestamp</span> timestamp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timestamp</span><span class="token punctuation">(</span>timeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>date<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>timestamp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>timestamp<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="完美的-equals-编写方法"><a href="#完美的-equals-编写方法" class="header-anchor">#</a> 完美的 equals 编写方法</h3> <p>编写一个完美的 equals 的顺序：</p> <ol><li>显示参数命名为 <code>otherObject</code></li> <li>检测 <code>this</code> 和 <code>otherObject</code> 是否引用同一个对象</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> otherObject<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="3"><li>检测 <code>otherObject</code> 是否为 <code>null</code></li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>otherObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="4"><li>比较 <code>this</code> 和 <code>otherObject</code> 是否是同一个类，这里分为两种情况
<ol><li>如果每个子类中比较的方式不同（即可能存在不同的私有域），则通过 <code>getClass</code> 进行比较</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> otherObject<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="2"><li>如果所有的子类都拥有统一的语义，例如 <code>java.sql.Date</code> 和 <code>java.sql.Time</code> ,就通过 <code>instanceof</code> 比较即可</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>otherObject <span class="token keyword">instanceof</span> <span class="token class-name">ClassName</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li>将 otherObject 强转为隐式参数对应的类型</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ClassName</span> other <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ClassName</span><span class="token punctuation">)</span>otherObject<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol start="6"><li>比较各个私有域，通过 <code>==</code> 比较基本类型，通过 <code>Objects.equals</code> 比较对象</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>field1 <span class="token operator">==</span> other<span class="token punctuation">.</span>field1
      <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>field2<span class="token punctuation">,</span> other<span class="token punctuation">.</span>field2<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="7"><li>如果需要在子类中重写 <code>equals</code> ，则通过 <code>super.equals(otherObject)</code> 调用父类的方法，再比较子类特有的私有域即可。</li></ol> <h3 id="数组的比较"><a href="#数组的比较" class="header-anchor">#</a> 数组的比较</h3> <p>对于数组类型的域，通过静态方法 `Arrays.equals() 检测即可。API 如下:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token class-name">Boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> type<span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>它会检查两个数组的长度是否相同，并且在对应的位上数据元素是否也相同才返回 true。</p> <h3 id="hashcode-方法"><a href="#hashcode-方法" class="header-anchor">#</a> hashCode 方法</h3> <p>hashcode 是由对象导出的一个<strong style="color:#3EAF7C;">整型值</strong>。在 Object 中默认的散列码实现是<strong style="color:#3EAF7C;">对象的存储地址</strong></p> <h4 id="equals-和-hashcode"><a href="#equals-和-hashcode" class="header-anchor">#</a> equals 和 hashcode</h4> <p>当我们重写 equals 方法时，也必须重写 hashcode 方法，反之也一样，否则它会影响到我们使用 HashMap 的插入。它们之间的关系如下：</p> <ul><li>如果存在 <code>o1.equals(o2)</code> 返回 true，则 <code>o1</code> 和 <code>o2</code> 的 <code>hashcode</code> 也必须相等</li> <li>如果 <code>o1</code> 和 <code>o2</code> 的hashcode相等，并不需要 <code>o1.equals(o2)</code> 返回 true。</li></ul> <div class="custom-block danger"><p class="custom-block-title">注意</p> <p>在自定义 equals 方法时使用哪个域进行比较，在 hashcode 方法中也需要用对应域来进行 hash。例如在 Employee 中 equals 通过 Id 来进行比较，那么在 hashcode 方法中就需要散列 Id,而不是散列雇员的名称或存储地址等域。</p></div> <h4 id="hashcode-相关api"><a href="#hashcode-相关api" class="header-anchor">#</a> hashcode 相关API</h4> <p>想要生成 hashcode，有三种方式：</p> <ul><li>通过调用 <code>obj.hashCode()</code> 方法</li> <li>通过 <code>Objects.hashCode(obj)</code> 或其它包装类，例如 <code>Double.hashCode(obj)</code></li> <li>如果需要组合 hash，可以通过 <code>Objects.hash(Object... objs)</code></li></ul> <h3 id="tostring-方法"><a href="#tostring-方法" class="header-anchor">#</a> toString 方法</h3> <p>这个方法比较简单，默认输出的是对象值的字符串。比较好的写法如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token operator">+</span> <span class="token string">&quot;[field1=&quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>field1
      <span class="token operator">+</span> <span class="token string">&quot;field2=&quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>field2
      <span class="token operator">+</span> <span class="token string">&quot;field3=&quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>field3
      <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="custom-block tip"><p class="custom-block-title">小技巧</p> <p>如果想要打印数组，可以通过 <code>Arrays.toString()</code> ，如果打印的是多维数组，则可以通过 <code>Arrays.deepToString()</code></p></div> <h2 id="对象包装器和自动装箱"><a href="#对象包装器和自动装箱" class="header-anchor">#</a> 对象包装器和自动装箱</h2> <p>在 Java 中，如果想要将基本数据类型转换为对象，可以使用对象包装器，其中每个基本数据类型都存在一个对应的对象包装器：</p> <table><thead><tr><th style="text-align:center;">基本类型</th> <th style="text-align:center;">包装器</th> <th style="text-align:center;"></th> <th>基本类型</th> <th style="text-align:center;">包装器</th></tr></thead> <tbody><tr><td style="text-align:center;">byte</td> <td style="text-align:center;">Byte</td> <td style="text-align:center;"></td> <td>double</td> <td style="text-align:center;">Double</td></tr> <tr><td style="text-align:center;">short</td> <td style="text-align:center;">Short</td> <td style="text-align:center;"></td> <td>long</td> <td style="text-align:center;">Long</td></tr> <tr><td style="text-align:center;">int</td> <td style="text-align:center;">Integer</td> <td style="text-align:center;"></td> <td>char</td> <td style="text-align:center;">Character</td></tr> <tr><td style="text-align:center;">float</td> <td style="text-align:center;">Float</td> <td style="text-align:center;"></td> <td>boolean</td> <td style="text-align:center;">Boolean</td></tr></tbody></table> <h3 id="自动装箱"><a href="#自动装箱" class="header-anchor">#</a> 自动装箱</h3> <p>自动装箱是把基本数据类型转换成对象。</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>在JDK1.5以前， 使用 Integer i = 5；是错误的，必须使用 Integer i = new Integer(5)</p></div> <p>在JDK1.5后，使用 Integer i = 5 ; 是正确的，因为它为我们自动执行了 <code>Integer i = Integer.valueOf(5)</code>, 这就是自动装箱。也就是说，<strong style="color:#3EAF7C;">自动装箱其实就是调用了对应包装类的 <code>valueOf(x)</code> 方法。</strong></p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>自动装箱要求 boolean、byte、char &lt;= 127</p></div> <h3 id="自动拆箱"><a href="#自动拆箱" class="header-anchor">#</a> 自动拆箱</h3> <p>自动拆箱就是把包装类转换为基本数据类型，例如 ：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">// 执行拆箱</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可以将变量引用 <code>i</code> 赋值给基本数据类型变量 <code>a</code> ，这就是自动拆箱，<strong style="color:#3EAF7C;">实际上是调用了 intValue()方法</strong>。</p> <div class="custom-block danger"><p class="custom-block-title">注意</p> <p>自动装箱、拆箱并不是虚拟机做的，而是我们的编译器认可的，编译器会自动帮我们在对应代码中插入一条 <code>valueof()</code> 或 <code>xxxValue()</code>,然后再让虚拟机去执行。</p></div> <h3 id="integer-的秘密"><a href="#integer-的秘密" class="header-anchor">#</a> Integer 的秘密</h3> <p>在 Integer 的 <code>valueOf</code> 方法中，有这么一段代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>它先判断 <code>i</code> 的值是否处于 <code>IntegerCache.low</code> 和 <code>IntegerCache.high</code> 之间，然后再决定创不创对象，也就是说，如果我们创建了在这个区间内的<code>Integer</code> 对象，则返回的将会是同一个对象地址。例如 ：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Integer</span> number1 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> number2 <span class="token operator">=</span> <span class="token number">120</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>number1 <span class="token operator">==</span> number2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里就会输出 <code>true</code> 。<strong style="color:#3EAF7C;">这是因为 Integer 把这些常用的数都给缓存起来了</strong>。方便我们快速返回，而不用重新创建。</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>这样的缓存机制，在 Short 包装器中也存在，缓存的范围也是 -128 到 127</p></div> <h2 id="枚举类"><a href="#枚举类" class="header-anchor">#</a> 枚举类</h2> <p>在 Java 中，定义一个拥有一系列常量的类，称为枚举类，通过关键字 <code>enum</code> 定义 ：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Size</span> <span class="token punctuation">{</span>
  SMALL<span class="token punctuation">,</span> MEDIUM<span class="token punctuation">,</span> LARGE<span class="token punctuation">,</span> EXTRA_LARGE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>实际上，这个声明定义的类型是一个类，而 <code>SMALL</code>、<code>MEDIUM</code>、<code>LARGE</code>、<code>EXTRA_LARGE</code> 是类的四个实例，尽量不要在代码中动态创建新实例。因此，对于枚举对象，只要用 <code>==</code> 来比较引用即可，无需用 <code>equals</code> 来比较两个对象。</p> <p>还可以往枚举类中添加一些构造器、方法和域，其中<strong style="color:#3EAF7C;">构造器只是在构建枚举常量的时候被调用</strong>，例如：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Size</span> <span class="token punctuation">{</span>
  <span class="token function">SMALL</span><span class="token punctuation">(</span><span class="token string">&quot;S&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">MEDIUM</span><span class="token punctuation">(</span><span class="token string">&quot;M&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">LARGE</span><span class="token punctuation">(</span><span class="token string">&quot;L&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EXTRA_LARGE</span><span class="token punctuation">(</span><span class="token string">&quot;XL&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">private</span> <span class="token class-name">String</span> abbreviation<span class="token punctuation">;</span>

  <span class="token keyword">private</span> <span class="token class-name">Size</span><span class="token punctuation">(</span><span class="token class-name">String</span> abbreviation<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>abbreviation <span class="token operator">=</span> abbreviation<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getAbbreviation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> abbreviation<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="enum-类"><a href="#enum-类" class="header-anchor">#</a> Enum 类</h3> <p>其实，所有的枚举类型都是 <code>Enum</code> 的子类，它们继承了许多的方法。</p> <h4 id="tostring"><a href="#tostring" class="header-anchor">#</a> toString</h4> <p>其中比较有用的是 <code>toString()</code> ，这个方法能够返回枚举的常量名，例如：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Size</span><span class="token punctuation">.</span>SMALL<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>将会返回字符串 <code>SMALL</code> 。</p> <h4 id="valueof"><a href="#valueof" class="header-anchor">#</a> valueOf</h4> <p>与 <code>toString()</code> 对应的方法是 <code>valueOf</code> ，可以通过一个字符串获取一个枚举对象 ：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Size</span> s <span class="token operator">=</span> <span class="token class-name">Enum</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token class-name">Size</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">&quot;SMALL&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>执行后 <code>s</code> 将会指向 <code>Size.SMALL</code> 。</p> <h4 id="values"><a href="#values" class="header-anchor">#</a> values</h4> <p>如果想要获取一个枚举类中的所有值数组，可以通过 <code>values</code> 方法：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Size</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> <span class="token class-name">Size</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="ordinal"><a href="#ordinal" class="header-anchor">#</a> ordinal</h4> <p>可以返回一个枚举常量在类中的位置，从 <code>0</code> 开始计数，例如：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Size</span><span class="token punctuation">.</span>MEDIUN<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>将会返回 <code>1</code> 。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">2020-2-24 11:57:31 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/java/baseJava/对象与类.html" class="prev">
        面向对象
      </a></span> <span class="next"><a href="/java/baseJava/反射.html">
        反射
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.78cba7d9.js" defer></script><script src="/assets/js/2.b97de27f.js" defer></script><script src="/assets/js/31.4bc393d7.js" defer></script>
  </body>
</html>
